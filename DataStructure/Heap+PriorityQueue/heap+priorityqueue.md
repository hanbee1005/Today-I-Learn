# Heap + Priority Queue

**완전 이진 트리**
- **이진 트리**란, 한 노드가 최대 두개의 노드를 자식 노드로 가질 수 있는 트리입니다.
- **완전 이진 트리**는 그중에서도 마지막 레벨을 제외한 모든 레벨에는 노드들이 가득 차 있고, 마지막 레벨의 노드들도 좌측부터 순서대로 들어가 있는 형태의 이진 트리입니다.
- 구조적 특징
	+ 현재 노드 번호를 i라 할때, (Root node가 0번일 경우 기준)
 		- 현재 노드의 perent node의 번호 = ***(i - 1) / 2***
 		- 현재 노드의 left child node의 번호 = ***i * 2 + 1***
		- 현재 노드의 right child node의 번호 = ***i * 2 + 2***
                                                     
**힙(Heap)**                           
- 완전 이진 트리로 구현된 자료 구조입니다.
- 완전 이진 트리의 구조적 특징으로 배열을 통해 구현 가능합니다.
- 종류
	+ 최소힙(Min Heap): 부모 노드가 가진 값은 자식 노드의 값보다 **무조건 작아야 한다.**
	+ 최대힙(Max Heap): 부모 노드가 가진 값은 자식 노드의 값보다 **무조건 커야 한다.**
- 구현 방법 (Max Heap 기준)
	+ 데이터 추가 - ```O(logN)```
		1. 새로운 노드를 트리의 맨 뒤에 추가합니다. (완전 이진 트리의 형태를 깨지 않고)
		2. 추가한 노드의 부모 노드와 비교하여 자식 노드가 더 크다면 서로의 위치를 바꿉니다.
		3. 2번 작업을 부모 노드가 더 클 때까지 반복합니다.
	+ 데이터 삭제 - ```O(logN)```
		1. 맨 뒤에 있는 노드를 root 자리로 옮깁니다.
		2. 자식 노드 중 더 큰 값과 비교하여 자식 노드의 값이 더 크면 서로의 위치를 바꿉니다.
		3. 2번 작업을 자신이 자식 노드보다 클 때까지 반복합니다.
- 활용
	+ 힙 정렬
	+ 다익스트라 알고리즘
                                                     
**우선 순위 큐(Priority Queue)**
- 들어온 순서와 상관없이 우선 순위가 가장 크거나 작은 자료가 먼저 나가는 자료구조입니다.
- 힙을 이용하여 가장 크거나 작은 데이터를 ```O(1)``` 시간만에 찾아낼 수 있습니다.
- 우선 순위 큐를 구현하면
	+ 배열로 구현된 하나의 힙을 가지고
	+ 우선 순위가 가장 높은 값을 빼내는 pop()
	+ 데이터를 추가하는 push() 연산이 존재하게 됩니다.

### 연관 문제
- [703. Kth Largest Element in a Stream](https://github.com/hanbee1005/AlgorithmStudy/blob/master/Leetcode/202301/KthLargestElementInAStream_703.java)
- [347. Top K Frequent Elements](https://github.com/hanbee1005/AlgorithmStudy/blob/master/Leetcode/202301/TopKFrequentElements_347.java)