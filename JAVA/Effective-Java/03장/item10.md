# Item10. equals는 일반 규약을 지켜 재정의하라
### 핵심 정리
- equals를 재정의하지 않는 것이 최선
    - 다음의 경우에 해당한다면 equals를 재정의할 필요가 없다.
        - 각 인스턴스가 본질적으로 고유하다. → 싱글톤, Enum 등
        - 인스턴스의 ‘논리적 동치성’을 검사할 필요가 없다. → 객체의 동일성 x, 논리적 동치성 = 값(내용)이 같은가?
        - 상위 클래스에서 정의한 equals가 하위 클래스에도 적절하다. → List, Set 등을 구현할 때
        - 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다.
- equals 규약
    - 반사성: A.equals(A) == true
    - 대칭성: A.equals(B) == B.equals(A)
        - CaseInsensitiveString 예제 코드!
    - 추이성: A.equals(B) && B.eqauls(C), A.equals(C)
        - Point, ColorPoint(inherit), CounterPointer, ColorPoint(comp) 예제 코드!
        - StackOverflowError가 날 수 있음…
        - 클래스를 상속 받아서 새로운 필드를 추가하는 경우에는 equals 규약을 만족시킬 방법이 없다… → Composition을 권장 (상속 없이 필드로 선언하는 방법)
    - 일관성: A.equals(B) == A.equals(B)
        - 불변 객체는 무조건 지킬 수 있지만 가변 객체는 일관성이 없을 수 있음
        - URL 의 equals는 너무 복잡하게 구현됨… → host가 가리키는 ip가 다르면 다르다고 나옴
    - null-아님: A.equals(null) == false
- equals 구현 방법
    - == 연산자를 사용해 자기 자신의 참조인지 확인한다.
    - instanceof 연산자로 올바른 타입인지 확인한다.
    - 입력된 값을 올바른 타입으로 형변환한다.
    - 입력 객체와 자기 자신의 대응되는 핵심 필드가 일치하는지 확인한다.
        - Lock 비교하지 말자!
        - 부동 소수점 관련 비교는 `Double.compare()`, `Float.compare()` 등으로 비교
        - Reference 타입은 그에 맞는 equals 비교
        - null 비교도 해야한다면 `Objects.equals()` 비교
    - 그외
        - 구글의 AutoValue 또는 Lombok을 사용한다.
        - IDE의 코드 생성 기능을 사용한다.
        - 과제) 자바의 Record 공부해보기
- 주의 사항
    - equals를 재정의할 때 hashCode도 반드시 재정의 하자 (아이템 11)
    - 너무 복잡하게 해결하지 말자
    - Object가 아닌 타입의 매개변수를 받는 equals 메서드는 선언하지 말자 → Override가 아님!
### 완벽 공략
- Value 기반 클래스
    - 클래스처럼 생겼지만 int 처럼 동작하는 클래스
    - 식별자가 없고 불변이다. (final을 써서 immutable 하게)
    - 식별자가 아니라 인스턴스가 가지고 있는 상태를 기반으로 equals, hashCode, toString을 구현한다.
    - == 오퍼레이션이 아니라 equals 를 사용해서 동등성 비교를 한다.
    - 동일한(equals) 객체는 상호 교환 가능하다.
- StackOverflow
    - 로컬 변수와 객체가 저장되는 공간의 이름은?
    - 스택(Stack)과 힙(Heap)
    - 메서드 호출 시 스택에 스택 프레임이 쌓인다.
        - 무한루프, 재귀 호출 등이 있을 때 스택 프레임이 많이 쌓임
        - 스택 프레임에 들어있는 정보 : 메서드에 전달하는 매개 변수, 메서드 실행 끝내고 돌아갈 곳, 힙에 들어있는 객체에 대한 레퍼런스…
        - 그런데 더 이상 스택 프레임을 쌓을 수 없다면? → StackOverflowError
    - 스택의 사이즈를 조절하고 싶다면? → Xss1M, Xss2048M 등등 (정말 필요할 때만 사용!!!)
- 리스코프 치환 원칙
    - 객체 지향 5대 원칙 SOLID 중에 하나
    - 1994년 바바라 리스코프의 논문 “A Behavioral Notion of Subtyping”에서 기원한 객체 지향 원칙
    - “하위 클래스의 객체”가 “상위 클래스의 객체”를 대체하더라도 소프트웨어의 기능을 깨뜨리지 않아야 한다. (semantic over syntacic, 구문보다는 의미)
