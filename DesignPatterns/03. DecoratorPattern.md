# 데코레이터 패턴 (Decorator Pattern)

## 1. 패턴 이름과 종류
- **이름:** 데코레이터 패턴(Decorator Pattern)
- **종류:** 구조(Structural) 패턴

---

## 2. 용도(Intent)
객체에 새로운 행동을 **동적으로 추가**하기 위해, 객체를 감싸는(wrapper) 구조를 사용하는 패턴입니다.

---

## 3. 동기(Motivation)
커피 주문 시스템에서 ‘모카 추가’, ‘휘핑 추가’ 같은 옵션을  
상속만으로 해결하면 조합 폭발이 발생합니다.

데코레이터 패턴은 각각의 추가 옵션을 “감싸는” 방식으로 동적 조합을 가능하게 합니다.

---

## 4. 적용 대상(Applicability)
- 객체의 행동을 런타임에 확장하고 싶을 때  
- 조합 가능한 기능들이 많아서 상속으로 처리하면 폭발할 때  
- 투명하게 기능을 확장해야 할 때

---

## 5. 구조(Structure)

```

       (공통 인터페이스)
+----------------------+
|      Component       |
+----------------------+
| + operation()        |
+----------------------+
      ^           ^
      |           |
+-------------+   |
|Concrete     |   |
|Component    |   |
+-------------+   |
                  |
           +---------------------+
           |     Decorator       |<<abstract>>
           +---------------------+
           | - component:        |
           |       Component     |
           +---------------------+
                 ^          ^
                 |          |
          +-----------+  +-------------+
          |Concrete   |  | Concrete    |
          |DecoratorA |  | DecoratorB  |
          +-----------+  +-------------+

(스타버즈 예제에서는 Beverage 가 Component,
Espresso 가 ConcreteComponent,
Mocha, Whip 등이 ConcreteDecorator)

```

---

## 6. 구성 요소(Participants)
- **Component**: 공통 인터페이스  
- **ConcreteComponent**: 기본 객체  
- **Decorator**: Component를 포함하는(wrapper) 추상 클래스  
- **ConcreteDecorator**: 행동을 확장하는 클래스

---

## 7. 협동(Collaborations)
Decorator는 Component 인터페이스를 따르며  
내부에 실제 Component를 보관하고 메서드를 위임하면서 기능을 추가합니다.

---

## 8. 결과(Consequences)
### 장점
- 기능 확장을 런타임에 조립 가능  
- 상속보다 훨씬 유연  
- 클래스 폭발 방지

### 단점
- 중첩이 많아지면 디버깅 어려움  
- 구성 객체가 많아질 수 있음

---

## 9. 구현(Implementation)
- Decorator는 반드시 Component 인터페이스를 구현  
- 내부에 Component 인스턴스를 보관  
- 확장 기능은 위임 + 추가 로직으로 진행

---

## 10. 샘플 코드 (스타버즈 커피 예제)

```java
public abstract class Beverage {
    public abstract double cost();
}

public class Espresso extends Beverage {
    public double cost() {
        return 1.99;
    }
}

public abstract class CondimentDecorator extends Beverage {
    protected Beverage beverage;
}

public class Mocha extends CondimentDecorator {
    public Mocha(Beverage beverage) {
        this.beverage = beverage;
    }

    public double cost() {
        return beverage.cost() + 0.20;
    }
}
```

## 11. 사용 예(Known Uses)
- Java I/O 스트림 (InputStream → FilterInputStream 구조)
- Spring의 Proxy 기반 AOP
- Servlet Filter 체인 구조

## 12. 연관 패턴(Related Patterns)
- 전략 패턴: 알고리즘 교체
- 어댑터 패턴: 인터페이스 변경
- 컴포지트 패턴: 객체 트리 구성
