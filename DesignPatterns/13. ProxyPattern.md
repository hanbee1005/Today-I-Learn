# 프록시 패턴(Proxy Pattern)

## 1. 패턴 이름과 종류
- 이름: 프록시 패턴(Proxy Pattern)
- 종류: 구조(Structural) 패턴

---

## 2. 용도(Intent)
다른 객체에 대한 **대리인(Proxy)**을 제공하여 접근을 제어하거나  
지연 로딩, 원격 호출, 보안 등을 담당하게 하는 패턴입니다.

---

## 3. 동기(Motivation)
헤드퍼스트 예제  
- **원격 프록시(Remote Proxy)**: RMI를 이용한 뽑기 기계 상태 모니터링  
- **보호 프록시(Protection Proxy)**: 사람(Person) 객체에 대한 접근 권한(자기 자신 vs 다른 사람)에 따라 메서드 허용/차단  
이처럼 실제 객체에 바로 접근시키지 않고, 프록시를 통해 제어하면  
보안·원격·캐싱·지연 로딩 등을 깔끔하게 처리할 수 있습니다.

---

## 4. 적용 대상(Applicability)
- 네트워크를 통한 원격 객체 접근(원격 프록시)  
- 객체 생성 비용이 큰 경우, 필요할 때까지 생성을 미루고 싶을 때(가상 프록시)  
- 접근 권한에 따라 메서드를 제한해야 할 때(보호 프록시)  
- 캐싱, 로깅, 모니터링을 투명하게 넣고 싶을 때

---

## 5. 구조(Structure)

```

+-------------------+
|      Client       |
+-------------------+
         |
         v
+-------------------+
|      Subject      |<<interface>>
+-------------------+
| + request()       |
+-------------------+
      ^        ^
      |        |
+----------+  +-----------+
|  Proxy   |  |RealSubject|
+----------+  +-----------+
| - real:  |  | 실제 구현 |
|   Subject|  +-----------+
| + request()|
|   (접근제어,|
|    로깅 등)|
+-----------+

(Client 는 항상 Subject 타입을 바라보고,
Proxy 가 RealSubject 에 위임 + 부가기능 수행)

```

---

## 6. 구성 요소(Participants)
- **Subject 인터페이스**: RealSubject와 Proxy가 공통으로 구현  
- **RealSubject**: 실제 작업을 수행하는 객체  
- **Proxy**: RealSubject에 대한 대리인  
  - RealSubject 참조를 가지고, 필요 시 접근 제어/지연 로딩/원격 호출 등을 수행

---

## 7. 협동(Collaborations)
- Client는 Subject 인터페이스에만 의존  
- Proxy는 RealSubject를 생성하거나 참조하여 실제 작업을 위임  
- 부가 기능(보안, 캐싱, 로깅 등)은 Proxy에서 처리

---

## 8. 결과(Consequences)
### 장점
- 접근 제어, 로깅, 캐싱, 지연 로딩 등 부가기능을 깔끔하게 분리  
- 클라이언트 입장에서는 RealSubject와 동일한 인터페이스라 투명하게 사용 가능  

### 단점
- 클래스 수 증가  
- 간접 호출에 따른 약간의 성능 오버헤드

---

## 9. 구현(Implementation)
- 인터페이스 기반으로 Proxy와 RealSubject를 동일시  
- 동적 프록시(리플렉션, JDK Proxy, CGLIB)를 사용할 수도 있음  
- 스레드 안전/캐싱 등의 정책을 Proxy에 넣을 수 있음

---

## 10. 샘플 코드(간단 보호 프록시)

```java
public interface Person {
    String getName();
    void setName(String name);
    void setRating(int rating);
}

public class PersonImpl implements Person {
    private String name;
    private int rating;
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public void setRating(int rating) { this.rating = rating; }
}

public class OwnerProxy implements Person {
    private Person person;

    public OwnerProxy(Person person) { this.person = person; }

    public String getName() { return person.getName(); }
    public void setName(String name) { person.setName(name); }
    public void setRating(int rating) {
        System.out.println("자기 자신의 평점은 설정할 수 없습니다.");
    }
}
```

## 11. 사용 예(Known Uses)
- Java RMI
- Hibernate Lazy Loading
- Spring AOP의 프록시(트랜잭션, 보안, 로깅)
- HTTP 프록시, 캐시 프록시 등

## 12. 연관 패턴(Related Patterns)
- 데코레이터 패턴: 구조는 비슷하지만 목적이 다름
  + 프록시: 접근 제어/부가기능
  + 데코레이터: 기능 확장
- 어댑터 패턴: 인터페이스 변환 목적
- 브리지 패턴: 구현 분리 목적
