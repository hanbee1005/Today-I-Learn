# 어댑터 패턴(Adapter Pattern)

## 1. 패턴 이름과 종류
- 이름: 어댑터 패턴(Adapter Pattern)
- 종류: 구조(Structural) 패턴

---

## 2. 용도(Intent)
호환되지 않는 인터페이스를 가진 클래스들을  
동작할 수 있도록 **중간 변환기 역할**을 하는 패턴입니다.

---

## 3. 동기(Motivation)
칠면조(Turkey) 객체와 오리(Duck) 객체는 서로 다른 인터페이스를 가집니다.  
하지만 “오리처럼 행동하는 칠면조”가 필요한 상황이라면?  
어댑터가 칠면조를 감싸서 Duck 인터페이스에 맞게 행동을 변환합니다.

---

## 4. 적용 대상(Applicability)
- 기존 클래스를 수정할 수 없을 때  
- 두 인터페이스가 호환되지 않을 때  
- 라이브러리 교체 없이 기존 코드 재사용을 원할 때

---

## 5. 구조(Structure)

```

       (클라이언트가 기대하는 인터페이스)
+--------------------+
|      Target        |
+--------------------+
| + request()        |
+--------------------+
          ^
          |
+--------------------------+
|        Adapter           |
+--------------------------+
| - adaptee: Adaptee       |
+--------------------------+
| + request()              |
+--------------------------+
          |
          | uses
          v
+--------------------+
|      Adaptee       |
+--------------------+
| + specificRequest()|
+--------------------+

(Client → Target 타입으로 Adapter 를 사용,
Adapter 내부에서 Adaptee 의 specificRequest() 호출)

```

---

## 6. 구성 요소
- **Target**: 클라이언트가 기대하는 인터페이스  
- **Adaptee**: 기존 인터페이스를 가진 클래스  
- **Adapter**: Target 인터페이스를 구현하고 내부적으로 Adaptee 호출

---

## 7. 협동(Collaborations)
클라이언트는 Target 인터페이스만 사용합니다.  
Adapter는 Adaptee의 기능을 호출하여 Target 규칙에 맞게 변환합니다.

---

## 8. 결과(Consequences)
### 장점
- 기존 코드를 수정하지 않고 재사용  
- 인터페이스 불일치 문제 해결  
- 클라이언트는 변경 없이 사용 가능

### 단점
- 중간 계층 증가  
- 여러 개의 어댑터가 필요하면 복잡해짐

---

## 9. 구현(Implementation)
- 클래스 어댑터(상속 기반) vs 객체 어댑터(구성 기반)  
- 대부분 구성 기반 객체 어댑터 사용

---

## 10. 샘플 코드(Turkey → Duck)

```java
public interface Duck {
    void quack();
    void fly();
}

public interface Turkey {
    void gobble();
    void flyShort();
}

public class TurkeyAdapter implements Duck {
    private Turkey turkey;

    public TurkeyAdapter(Turkey turkey) {
        this.turkey = turkey;
    }

    public void quack() {
        turkey.gobble();
    }

    public void fly() {
        turkey.flyShort();
    }
}
```

## 11. 사용 예(Known Uses)
- Java I/O (InputStream → Reader 변환)
- Spring MVC의 HandlerAdapter
- JDBC 드라이버 래핑

## 12. 연관 패턴
- 데코레이터 패턴: 기능 확장 목적
- 퍼사드 패턴: 단순화 목적
- 브리지 패턴: 추상화 분리 목적
