# 인터프리터 패턴(Interpreter Pattern)

## 1. 패턴 이름과 종류
- 이름: 인터프리터 패턴(Interpreter Pattern)
- 종류: 행동(Behavioral) 패턴

---

## 2. 용도(Intent)
문법이 비교적 간단한 언어에 대해, 그 문법을 클래스로 표현하고  
해석(interpret) 기능을 제공하는 패턴입니다.

---

## 3. 동기(Motivation)
간단한 규칙 기반 언어, 미니 스크립트, 검색 조건 DSL 등을 만들 때  
문법에 해당하는 클래스를 정의하고,  
각 노드가 자신의 부분식(expression)을 해석하도록 합니다.

---

## 4. 적용 대상(Applicability)
- 언어/DSL의 문법이 간단하고 자주 변경되지 않을 때  
- 표현식을 객체 트리로 표현할 수 있을 때  
- 새로운 문법 요소를 클래스 추가로 표현하고 싶을 때

---

## 5. 구조(Structure)

```

        (추상 표현식)
+-------------------------+
|    AbstractExpression   |
+-------------------------+
| + interpret(Context)    |
+-------------------------+
        ^           ^
        |           |
+------------------+ +-----------------------+
|TerminalExpression| |NonterminalExpression  |
+------------------+ +-----------------------+
                         |
                         | has children
                         v
                  (다른 Expression 들로 구성)

+-------------------------+
|        Context          |
+-------------------------+
|  해석에 필요한 정보     |
+-------------------------+

- Client 가 Expression 들을 조합해서 구문 트리(Syntax Tree) 생성
- 루트 Expression 의 interpret() 를 호출하면 트리 전체를 따라 해석

```

---

## 6. 구성 요소(Participants)
- **AbstractExpression**: 공통 인터프리트 메서드 선언  
- **TerminalExpression**: 단말 기호에 대한 해석  
- **NonterminalExpression**: 다른 Expression들을 조합하여 해석  
- **Context**: 해석에 필요한 외부 정보 제공

---

## 7. 협동(Collaborations)
- Client는 구문 트리(Syntax Tree)를 구성  
- `interpret(context)` 호출 시, 각 노드가 자신과 자식 노드를 해석하여 결과 반환

---

## 8. 결과(Consequences)
### 장점
- 문법을 클래스로 정의하여 확장 용이  
- 새로운 표현식을 클래스 추가로 구현 가능

### 단점
- 문법이 복잡해질수록 클래스 수가 폭발적으로 증가  
- 성능 문제 가능성

---

## 9. 구현(Implementation)
- Composite 패턴과 함께 사용(표현식 트리)  
- Visitor 패턴과 결합하여 다양한 해석/변환을 제공할 수 있음

---

## 10. 샘플 코드(간단 숫자 더하기 표현식)

```java
public interface Expression {
    int interpret();
}

public class NumberExpression implements Expression {
    private int number;
    public NumberExpression(int number) { this.number = number; }
    public int interpret() { return number; }
}

public class AddExpression implements Expression {
    private Expression left, right;
    public AddExpression(Expression left, Expression right) {
        this.left = left; this.right = right;
    }
    public int interpret() {
        return left.interpret() + right.interpret();
    }
}
```

## 11. 사용 예(Known Uses)
- 정규식 엔진(개념적으로)
- 간단한 DSL(쿼리, 규칙 엔진 등)
- 게임 스크립트, 워크플로우 스크립트

## 12. 연관 패턴(Related Patterns)
- 컴포지트 패턴: 구문 트리 표현
- 비지터 패턴: 다양한 연산(해석, 최적화, 출력 등)

---

# 중재자 패턴(Mediator Pattern)

## 1. 패턴 이름과 종류
- 이름: 중재자 패턴(Mediator Pattern)
- 종류: 행동(Behavioral) 패턴

---

## 2. 용도(Intent)
여러 객체들 사이의 복잡한 상호작용을  
하나의 **중재자(Mediator)** 객체가 책임지도록 하여  
객체들 간의 의존성을 줄이는 패턴입니다.

---

## 3. 동기(Motivation)
대화 상자(Dialog) 예제  
- 버튼, 텍스트 필드, 체크박스 등 위젯들이 서로 상태를 바꿔야 할 때  
위젯들이 서로 직접 참조하면서 제어하면 상호 의존성이 매우 높아짐  
→ 중재자가 중앙에서 “버튼 클릭 → 텍스트 필드 활성화” 같은 로직을 관리

---

## 4. 적용 대상(Applicability)
- 객체 간 관계가 복잡할 때  
- 다대다 통신을 1:N 구조로 단순화하고 싶을 때  
- 컴포넌트 간 결합도를 낮추고 싶을 때

---

## 5. 구조(Structure)

```

           (조정자)
+---------------------------+
|         Mediator          |<<interface>>
+---------------------------+
| + notify(sender, event)   |
+---------------------------+
            ^
            |
+---------------------------+
|      ConcreteMediator     |
+---------------------------+
| - colleagues: List        |
+---------------------------+
   ^        ^         ^
   |        |         |
+------+ +------+ +------+
|Col1 | |Col2 | |Col3 |
+------+ +------+ +------+
(Colleague 들)

- 각 Colleague 는 자신의 상태 변화나 이벤트 발생 시 Mediator.notify(...) 호출
- ConcreteMediator 가 어떤 Colleague 에게 어떤 행동을 시킬지 결정

```

---

## 6. 구성 요소(Participants)
- **Mediator 인터페이스**: Colleague 간 상호작용 조정 메서드 정의  
- **ConcreteMediator**: 실제 협력 로직 구현  
- **Colleague**: 동료 객체, Mediator를 통해서만 서로 통신  

---

## 7. 협동(Collaborations)
- Colleague는 상태 변화가 발생하면 Mediator에 알림  
- Mediator는 다른 Colleague에게 적절한 동작을 지시

---

## 8. 결과(Consequences)
### 장점
- 객체 간 결합도 감소  
- 상호작용 로직을 중앙에서 관리  
- 컴포넌트 재사용성 증가

### 단점
- Mediator가 너무 비대해질 수 있음(“God object” 위험)

---

## 9. 구현(Implementation)
- 인터페이스 기반 Mediator/Colleague 설계  
- Colleague는 Mediator에만 의존하도록 설계

---

## 10. 샘플 코드(간단 채팅방 예제)

```java
public interface ChatMediator {
    void send(String msg, User user);
    void addUser(User user);
}

public class ChatMediatorImpl implements ChatMediator {
    private List<User> users = new ArrayList<>();

    public void addUser(User user) { users.add(user); }

    public void send(String msg, User user) {
        for (User u : users) {
            if (u != user) u.receive(msg);
        }
    }
}

public abstract class User {
    protected ChatMediator mediator;
    protected String name;

    public User(ChatMediator mediator, String name) {
        this.mediator = mediator; this.name = name;
    }

    public void send(String msg) { mediator.send(msg, this); }
    public abstract void receive(String msg);
}
```

## 11. 사용 예(Known Uses)
- GUI 다이얼로그 관리
- 채팅 시스템
- 항공 관제 시스템(관제탑 = Mediator)

## 12. 연관 패턴(Related Patterns)
- 옵저버 패턴: 한 방향 알림 vs Mediator의 양방향 조정
- 책임 연쇄 패턴: 체인 vs 중앙 집중

---

# 메멘토 패턴(Memento Pattern)

## 1. 패턴 이름과 종류
- 이름: 메멘토 패턴(Memento Pattern)
- 종류: 행동(Behavioral) 패턴

---

## 2. 용도(Intent)
객체의 내부 상태를 캡슐화를 깨뜨리지 않고  
외부에 저장했다가 나중에 그 상태로 복원할 수 있게 하는 패턴입니다.

---

## 3. 동기(Motivation)
텍스트 에디터의 **Undo 기능**  
- 편집 상태를 이전 단계로 되돌리고 싶지만  
- 내부 구현을 외부에 공개하고 싶지는 않음  
메멘토 객체에 상태를 저장해두면, 필요할 때 그 상태로 복원 가능

---

## 4. 적용 대상(Applicability)
- Undo/Redo 기능이 필요할 때  
- 특정 시점의 스냅샷을 저장/복원해야 할 때  
- 내부 상태 캡슐화를 유지하면서 백업하고 싶을 때

---

## 5. 구조(Structure)

```

+----------------------------+
|        Originator          |
+----------------------------+
| - state                    |
+----------------------------+
| + createMemento():Memento  |
| + restore(m:Memento)       |
+----------------------------+

+----------------------------+
|          Memento           |
+----------------------------+
|  (Originator 의 내부 상태)|
+----------------------------+

+----------------------------+
|        Caretaker           |
+----------------------------+
| - history: List<Memento>   |
+----------------------------+
| + addMemento(m)            |
| + getMemento(index)        |
+----------------------------+

- Originator: 자신의 상태를 Memento 로 캡슐화 / 복원
- Caretaker: Memento 를 보관만 하고 내부 내용은 모름

```

---

## 6. 구성 요소(Participants)
- **Originator**: 상태를 갖고 있는 객체, 메멘토 생성/복원  
- **Memento**: Originator의 내부 상태를 저장하는 객체  
- **Caretaker**: Memento를 보관/관리 (내용은 모른 채로 저장만)

---

## 7. 협동(Collaborations)
- Originator는 상태를 Memento에 저장하고 Caretaker에게 넘김  
- 복원이 필요하면 Caretaker가 Memento를 다시 Originator에 전달  
- Originator는 Memento로부터 자신의 상태를 복원

---

## 8. 결과(Consequences)
### 장점
- 캡슐화 유지  
- Undo/Redo 등 상태 복원이 쉬움

### 단점
- 많은 스냅샷 저장 시 메모리 비용 증가  
- 복잡한 객체의 경우 메멘토 구조 설계가 어려울 수 있음

---

## 9. 구현(Implementation)
- Memento를 내부 클래스(inner class)로 두어 캡슐화 강화  
- 여러 단계의 Undo를 위해 스택 구조로 관리

---

## 10. 샘플 코드(텍스트 에디터 단순 예)

```java
public class Editor {
    private String text;

    public void setText(String text) { this.text = text; }
    public String getText() { return text; }

    public Memento save() { return new Memento(text); }
    public void restore(Memento m) { this.text = m.text; }

    public static class Memento {
        private final String text;
        private Memento(String text) { this.text = text; }
    }
}
```

## 11. 사용 예(Known Uses)
- IDE, 문서 편집기의 Undo/Redo
- 게임 세이브 기능
- 워크플로우 엔진의 상태 롤백

## 12. 연관 패턴(Related Patterns)
- 커맨드 패턴: Undo를 커맨드 기반으로 구현할 수도 있음
- 프로토타입 패턴: 복제 vs 메멘토의 스냅샷

---

# 프로토타입 패턴(Prototype Pattern)

## 1. 패턴 이름과 종류
- 이름: 프로토타입 패턴(Prototype Pattern)
- 종류: 생성(Creational) 패턴

---

## 2. 용도(Intent)
기존 객체를 복제(clone)해서 새로운 객체를 만드는 패턴입니다.  
클래스로부터 직접 생성하는 대신, 이미 존재하는 인스턴스를 복제합니다.

---

## 3. 동기(Motivation)
- 복잡한 초기화 과정을 거쳐 만들어진 객체  
- 런타임에 어떤 구체 클래스를 인스턴스화해야 하는지 알 수 없을 때  
이럴 때는 “원형(프로토타입)” 객체를 준비해 두고, 필요할 때마다 복제하는 것이 유리합니다.

---

## 4. 적용 대상(Applicability)
- 생성 비용이 큰 객체를 자주 만들어야 할 때  
- 객체 생성 로직이 복잡하거나 동적인 경우  
- 객체의 종류가 런타임에 결정될 때

---

## 5. 구조(Structure)

```

             clone()
+-------------------------------+
|          Prototype            |<<interface/abstract>>
+-------------------------------+
| + clone(): Prototype          |
+-------------------------------+
        ^                 ^
        |                 |
+-------------------+  +---------------------+
|ConcretePrototypeA |  |ConcretePrototypeB   |
+-------------------+  +---------------------+

+----------------------+
|        Client        |
+----------------------+
| - prototype:         |
|     Prototype        |
+----------------------+
| + op() {             |
|   Prototype p =      |
|     prototype.clone();|
| }                    |
+----------------------+

- Client 는 new 대신 clone() 을 사용해 새 객체 생성

```

---

## 6. 구성 요소(Participants)
- **Prototype 인터페이스**: `clone()` 정의  
- **ConcretePrototype**: 실제 복제 가능한 객체  
- **Client**: Prototype을 복제해서 사용

---

## 7. 협동(Collaborations)
- Client는 `new` 대신 `clone()` 사용  
- Prototype은 깊은 복제/얕은 복제를 적절히 구현

---

## 8. 결과(Consequences)
### 장점
- 동적으로 객체 생성 패밀리를 만들 수 있음  
- 클래스 계층에 의존하지 않고 복제 가능  
- 초기화 비용이 큰 객체 재사용

### 단점
- 복제 논리(깊은/얕은 복사) 구현이 까다로울 수 있음  
- 순환 참조 등 복잡한 구조에서 주의 필요

---

## 9. 구현(Implementation)
- Java에서는 `Cloneable`과 `clone()` 오버라이드  
- 직접 복제 메서드를 구현하는 방식이 더 명시적일 때도 많음

---

## 10. 샘플 코드(간단 도형 복제 예제)

```java
public abstract class Shape implements Cloneable {
    protected String color;

    public void setColor(String color) { this.color = color; }

    @Override
    public Shape clone() {
        try {
            return (Shape) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException(e);
        }
    }
}

public class Circle extends Shape {
    private int radius;
    public void setRadius(int r) { radius = r; }
}
```

## 11. 사용 예(Known Uses)
- 스프라이트/게임 오브젝트 복제
- 프로토타입 기반 DI 컨테이너 스코프
- 그래픽 편집기에서 도형 복사/붙여넣기

## 12. 연관 패턴(Related Patterns)
- 추상 팩토리 / 팩토리 메서드: 클래스를 통해 생성 vs 프로토타입 복제
- 메멘토 패턴: 상태 스냅샷 vs 전체 객체 복제

---

# 비지터 패턴(Visitor Pattern)

## 1. 패턴 이름과 종류
- 이름: 비지터 패턴(Visitor Pattern)
- 종류: 행동(Behavioral) 패턴

---

## 2. 용도(Intent)
객체 구조를 변경하지 않고도  
그 객체 구조에 대해 새로운 연산을 쉽게 추가할 수 있게 하는 패턴입니다.

---

## 3. 동기(Motivation)
예: 파일 시스템 구조(폴더/파일)에  
- 용량 계산, 출력, 압축, 권한 검사 등 다양한 연산을 적용하고 싶을 때  
각 클래스에 메서드를 계속 추가하면 코드가 지저분해집니다.  
→ 비지터 패턴은 연산을 별도 객체(Visitor)로 분리하고,  
객체 구조는 `accept(visitor)`로 방문을 허용합니다.

---

## 4. 적용 대상(Applicability)
- 복잡한 객체 구조(트리 형태 등)가 있고, 여기에 여러 종류의 연산을 적용해야 할 때  
- 객체 구조는 잘 변하지 않지만, 연산이 자주 추가될 때

---

## 5. 구조(Structure)

```

        (요소 계층)
+-------------------------+
|        Element          |<<interface>>
+-------------------------+
| + accept(Visitor v)     |
+-------------------------+
        ^           ^
        |           |
+--------------------+  +---------------------+
|ConcreteElementA    |  |ConcreteElementB     |
+--------------------+  +---------------------+
| + accept(v) {      |  | + accept(v) {       |
|     v.visit(this); |  |     v.visit(this);  |
|   }                |  |   }                 |
+--------------------+  +---------------------+

         (방문자 계층)
+-------------------------+
|        Visitor          |<<interface>>
+-------------------------+
| + visit(ElementA)       |
| + visit(ElementB)       |
+-------------------------+
        ^           ^
        |           |
+--------------------+  +---------------------+
| ConcreteVisitor1   |  | ConcreteVisitor2    |
+--------------------+  +---------------------+

- Element 구조는 그대로 두고,
  Visitor 를 새로 추가하는 방식으로 연산을 확장

```

---

## 6. 구성 요소(Participants)
- **Element 인터페이스**: `accept(Visitor v)` 메서드 정의  
- **ConcreteElement**: 실제 요소, `accept`에서 `v.visit(this)` 호출  
- **Visitor 인터페이스**: 각 ConcreteElement 타입에 대한 `visitXxx()` 메서드 정의  
- **ConcreteVisitor**: 실제 연산 구현

---

## 7. 협동(Collaborations)
- Element는 Visitor를 받아들이고, 자신을 인자로 전달하며 `visit()` 호출  
- Visitor는 전달받은 Element 타입에 따라 적절한 연산을 수행  
- Double Dispatch를 활용하여 타입에 따라 다른 연산 수행

---

## 8. 결과(Consequences)
### 장점
- 객체 구조 변경 없이 새 연산 추가 가능  
- 연산 로직을 한 곳에 모을 수 있어 응집도 증가

### 단점
- 객체 구조가 자주 바뀌면 Visitor 인터페이스도 계속 수정해야 함  
- 새로운 Element 타입 추가가 어려움

---

## 9. 구현(Implementation)
- 각 Element는 `accept(Visitor)` 구현 필수  
- Visitor는 모든 Element 타입에 대한 visit 메서드를 제공  
- 보통 컴포지트 패턴과 함께 사용(트리 순회)

---

## 10. 샘플 코드(간단 예제)

```java
public interface Element {
    void accept(Visitor v);
}

public class ConcreteElementA implements Element {
    public void accept(Visitor v) {
        v.visit(this);
    }
}

public interface Visitor {
    void visit(ConcreteElementA e);
    // void visit(ConcreteElementB e); ...
}

public class PrintVisitor implements Visitor {
    public void visit(ConcreteElementA e) {
        System.out.println("ElementA 출력");
    }
}
```

## 11. 사용 예(Known Uses)
- 컴파일러(AST에 대한 다양한 패스: 타입 체크, 코드 생성 등)
- XML/JSON DOM 트리 처리
- 복잡한 도메인 모델에 대한 여러 보고서/통계 산출

## 12. 연관 패턴(Related Patterns)
- 컴포지트 패턴: 트리 구조를 Visitor가 순회하며 연산
- 인터프리터 패턴: 구문 트리에 대한 연산
- 더블 디스패치(Double Dispatch) 개념과 밀접
