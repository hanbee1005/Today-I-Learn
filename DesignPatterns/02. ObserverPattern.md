# 옵저버 패턴 (Observer Pattern)

## 1. 패턴 이름과 종류
- **이름:** 옵저버 패턴(Observer Pattern)
- **종류:** 행동(Behavioral) 패턴

---

## 2. 용도(Intent)
객체 사이에 **1:N 의존 관계**를 정의하여, 한 객체의 상태가 바뀌면  
연관된 객체들이 자동으로 **알림(notification)**을 받고 갱신되도록 만드는 패턴입니다.

---

## 3. 동기(Motivation)
기상 스테이션(WeatherData)이 새로운 온도·습도·기압 데이터를 생성하면  
여러 디스플레이(현재 상태/날씨 예보 등)가 자동으로 갱신되어야 합니다.

옵저버 패턴은 “데이터가 바뀔 때마다 자동으로 알려준다”는 구조를 제공합니다.

---

## 4. 적용 대상(Applicability)
- 한 객체의 상태 변화가 다른 객체들에게 자동으로 전달돼야 할 때  
- 느슨한 결합(loose coupling)을 만들고 싶을 때  
- 이벤트 기반 시스템

---

## 5. 구조(Structure)

```
+-------------------+
|      Subject      |
+-------------------+
| + register(o)     |
| + remove(o)       |
| + notify()        |
+-------------------+
          |
   manages many
          v
+-------------------+
|     Observer      |<<interface>>
+-------------------+
| + update(...)     |
+-------------------+
     ^          ^
     |          |
+-----------+  +------------+
|Concrete   |  | Concrete   |
|ObserverA  |  | ObserverB  |
+-----------+  +------------+

(WeatherData 같은 ConcreteSubject 가 Subject 를 구현하고,
각 디스플레이가 ConcreteObserver 로 동작)
```

---

## 6. 구성 요소(Participants)
- **Subject**: 옵저버 등록/해제/알림 기능 제공  
- **Observer 인터페이스**: `update()` 정의  
- **ConcreteObserver**: 알림 받는 실제 객체  
- **ConcreteSubject**: 실제 데이터 소유 객체 (예: WeatherData)

---

## 7. 협동(Collaborations)
Subject는 옵저버 목록을 관리하며, 상태가 바뀌면 Observer들의 `update()` 메서드를 호출합니다.

---

## 8. 결과(Consequences)
### 장점
- 느슨한 결합  
- 자동 업데이트  
- 새로운 옵저버 추가가 용이

### 단점
- 옵저버가 많으면 알림 비용 증가  
- 업데이트 순서를 보장하기 힘듦

---

## 9. 구현(Implementation)
- Push 방식 / Pull 방식 선택 가능  
- 옵저버 등록/해제는 반드시 제공  
- Subject는 옵저버를 구체적으로 몰라야 함

---

## 10. 샘플 코드 (Weather 예제)

```java
public interface Observer {
    void update(float temp, float humidity, float pressure);
}

public interface Subject {
    void registerObserver(Observer o);
    void removeObserver(Observer o);
    void notifyObservers();
}

public class WeatherData implements Subject {
    private List<Observer> observers = new ArrayList<>();
    private float temperature;

    public void measurementsChanged() {
        notifyObservers();
    }

    public void notifyObservers() {
        for (Observer o : observers) {
            o.update(temperature, 0, 0);
        }
    }
}
```

## 11. 사용 예(Known Uses)
- GUI 이벤트 리스너
- 메시지 브로커(MQTT, Kafka의 subscribe 구조)
- React의 상태 업데이트 개념

## 12. 연관 패턴(Related Patterns)
- 메디에이터 패턴: 전체 상호작용을 중앙에서 조율
- 퍼블리셔-서브스크라이버 패턴: 옵저버의 확장 모델
