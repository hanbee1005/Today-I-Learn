# 상태 패턴(State Pattern)

## 1. 패턴 이름과 종류
- 이름: 상태 패턴(State Pattern)
- 종류: 행동(Behavioral) 패턴

---

## 2. 용도(Intent)
객체의 내부 상태에 따라 객체의 행동이 바뀌도록 만드는 패턴입니다.  
마치 객체의 클래스를 런타임에 바꾸는 것처럼 보이게 합니다.

---

## 3. 동기(Motivation)
헤드퍼스트 예제의 **뽑기 기계(Gumball Machine)**  
- 동전 없음, 동전 있음, 알맹이 판매, 품절 등 여러 상태를 가짐  
- `if/else`나 `switch`로 상태를 분기하면 코드가 복잡해지고 유지보수가 어려움  
→ 각 상태를 **별도 클래스**로 분리하고, 현재 상태 객체에 행동을 위임하면 상태별 행동을 깔끔하게 관리할 수 있음.

---

## 4. 적용 대상(Applicability)
- 객체가 여러 상태를 가지며, 상태에 따라 행동이 달라질 때  
- 상태 전환 로직이 복잡해져 조건문이 난무할 때  
- 상태 관련 코드를 한 곳에 모으고 싶을 때

---

## 5. 구조(Structure)

```

+--------------------------+
|         Context          |
+--------------------------+
| - state: State           |
+--------------------------+
| + requestX()             |
| + requestY()             |
| + setState(State)        |
+--------------------------+
           |
           v
+--------------------------+
|          State           |<<interface>>
+--------------------------+
| + handleX(Context)       |
| + handleY(Context)       |
+--------------------------+
      ^               ^
      |               |
+-------------+   +-------------+
| Concrete    |   | Concrete    |
| StateA      |   | StateB      |
+-------------+   +-------------+

(Context 의 메서드는 대부분 현재 state 에 위임,
각 ConcreteState 가 필요시 Context.setState(...) 호출)

```

---

## 6. 구성 요소(Participants)
- **Context**  
  - 현재 상태를 나타내는 `State` 참조를 가짐  
  - 작업 수행을 상태 객체에 위임  
- **State 인터페이스**  
  - 상태별로 달라지는 메서드 정의 (예: `insertQuarter()`, `turnCrank()` 등)  
- **ConcreteState들**  
  - 각 상태에 대한 구체 구현  
  - 필요 시 Context의 상태를 다른 상태로 변경

---

## 7. 협동(Collaborations)
- Context는 자신의 요청을 현재 `state` 객체에 위임  
- 각 ConcreteState는 상황에 따라 Context의 상태를 다른 ConcreteState로 변경하여 상태 전이를 처리

---

## 8. 결과(Consequences)
### 장점
- 조건문 남발 없이 상태별 행동을 분리  
- 새로운 상태를 추가할 때 기존 코드 변경 최소화  
- 각 상태별 로직이 잘 응집됨

### 단점
- 상태 클래스 수 증가  
- 매우 단순한 상태 전환에는 과한 설계가 될 수 있음

---

## 9. 구현(Implementation)
- 상태 전이는 상태 객체 내부에서 하거나, Context가 제어하게 할 수 있음  
- 상태 객체를 싱글턴으로 공유할지, 인스턴스를 매번 생성할지 결정  
- Context는 상태의 추상 타입만 알고 있어야 함

---

## 10. 샘플 코드(Gumball 예제 단순화)

```java
public interface State {
    void insertQuarter();
    void turnCrank();
}

public class NoQuarterState implements State {
    private GumballMachine machine;

    public NoQuarterState(GumballMachine machine) {
        this.machine = machine;
    }

    public void insertQuarter() {
        System.out.println("동전을 넣으셨습니다.");
        machine.setState(machine.getHasQuarterState());
    }

    public void turnCrank() {
        System.out.println("동전을 먼저 넣어야 합니다.");
    }
}

public class GumballMachine {
    private State noQuarterState;
    private State hasQuarterState;

    private State state;

    public GumballMachine() {
        noQuarterState = new NoQuarterState(this);
        hasQuarterState = new HasQuarterState(this);
        state = noQuarterState;
    }

    public void setState(State s) { state = s; }

    public State getHasQuarterState() { return hasQuarterState; }

    public void insertQuarter() { state.insertQuarter(); }
    public void turnCrank() { state.turnCrank(); }
}
```

## 11. 사용 예(Known Uses)
- 헤드퍼스트: 뽑기 기계(Gumball Machine)
- 게임 캐릭터 상태(걷기, 공격, 피격 등)
- 네트워크 연결 상태(연결 전, 연결 중, 연결됨, 종료 등)

## 12. 연관 패턴(Related Patterns)
- 전략 패턴: 구조는 비슷하지만 목적이 다름
  + 전략: 알고리즘 교체
  + 상태: 상태 전이에 따른 행동 변화
- 싱글턴 패턴: 각 상태를 싱글턴으로 관리할 때 함께 사용됨
