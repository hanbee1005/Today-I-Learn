# 전략 패턴 (Strategy Pattern)

## 1. 패턴 이름과 종류  
- **이름:** 전략 패턴(Strategy Pattern)  
- **종류:** 행동(Behavioral) 패턴

---

## 2. 용도(Intent)
알고리즘 군(群)을 정의하고, 각각을 캡슐화하여 교환 가능하게 만드는 패턴입니다.  
클라이언트는 알고리즘을 변경하지 않고도 런타임에 행동을 바꿀 수 있습니다.

---

## 3. 동기(Motivation)
오리(duck) 객체들이 서로 다른 `날기(fly)`와 `울기(quack)` 행동을 가질 때,  
상속만으로 해결하면 행동이 중복되고 변경이 어려워지는 문제가 생깁니다.

→ 전략 패턴은 이 ‘변하는 부분’을 별도 객체로 분리하여 유연하게 바꿀 수 있도록 해줍니다.

---

## 4. 적용 대상(Applicability)
- 객체가 수행하는 행동을 **런타임에 바꾸고 싶을 때**  
- 유사한 알고리즘들이 여러 개 존재하고, 그것들을 **교체 가능하게** 만들고 싶을 때  
- 조건문(if/switch)로 알고리즘 분기가 반복될 때

---

## 5. 구조(Structure)

```
+-------------------+
|      Context      |
+-------------------+
| - strategy:       |
|       Strategy    |
+-------------------+
| + setStrategy()   |
| + doSomething()   |
+-------------------+
          |
          v
+-------------------+
|     Strategy      |<<interface>>
+-------------------+
| + execute()       |
+-------------------+
     ^          ^
     |          |
+-----------+  +------------+
|Concrete   |  | Concrete   |
|StrategyA  |  | StrategyB  |
+-----------+  +------------+
```

---

## 6. 구성 요소(Participants)
- **Context**: 전략 객체를 사용하고, 실행 시 어떤 전략을 쓸지 유지  
- **Strategy 인터페이스**: 공통 행동 정의  
- **ConcreteStrategy**: 실제 알고리즘 구현체들 (예: `FlyWithWings`, `FlyNoWay`)

---

## 7. 협동(Collaborations)
Context는 Strategy 인터페이스만 알고 있으며, 실제 작업은 ConcreteStrategy에 위임합니다.  
알고리즘 변경은 `setStrategy()`로 교체하며 Context 내부 로직을 건드리지 않습니다.

---

## 8. 결과(Consequences)
### 장점
- 알고리즘을 독립적이고 유연하게 교체 가능  
- 상속 구조 난잡함 제거  
- 조건문 제거

### 단점
- 전략 객체가 많아질 수 있음  
- 클라이언트가 전략을 직접 선택해야 하는 경우가 있음

---

## 9. 구현(Implementation)
- 전략 객체는 **인터페이스 기반**으로 구성  
- 변경 가능성이 높은 로직만 분리  
- Context는 전략을 생성자 또는 setter로 주입받도록 설계

---

## 10. 샘플 코드 (Duck 예제 – Head First 기반)

```java
public interface FlyBehavior {
    void fly();
}

public class FlyWithWings implements FlyBehavior {
    public void fly() {
        System.out.println("날개로 힘차게 날아요!");
    }
}

public class FlyNoWay implements FlyBehavior {
    public void fly() {
        System.out.println("저는 못 날아요...");
    }
}

public abstract class Duck {
    FlyBehavior flyBehavior;

    public void performFly() {
        flyBehavior.fly();
    }

    public void setFlyBehavior(FlyBehavior fb) {
        this.flyBehavior = fb;
    }
}
```

## 11. 사용 예(Known Uses)
- 자바 정렬 API의 Comparator 전략
- 스프링의 DI/IoC 기반 전략 교체
- GUI에서 행동(Action) 교체

## 12. 연관 패턴(Related Patterns)
- 상태 패턴(State): 객체 상태에 따라 행동이 달라짐
- 데코레이터 패턴: Strategy가 알고리즘 자체를 교체한다면, Decorator는 행동을 확장함
