# 브리지 패턴(Bridge Pattern)

## 1. 패턴 이름과 종류
- 이름: 브리지 패턴(Bridge Pattern)
- 종류: 구조(Structural) 패턴

---

## 2. 용도(Intent)
추상화(abstraction)와 구현(implementation)을 분리하여  
둘을 독립적으로 변경할 수 있게 하는 패턴입니다.

---

## 3. 동기(Motivation)
예: 리모컨 + TV 구조  
- 리모컨: 기능(켜기, 끄기, 볼륨 조절 등)  
- TV: 실제 구현(삼성 TV, LG TV, 샤오미 TV 등)  
상속만으로 “삼성TV용 고급리모컨”, “LGTV용 기본리모컨” 등을 만들면  
클래스 조합이 폭발합니다.  
→ 리모컨(추상화)과 TV(구현)를 **분리**해놓고, 런타임에 조합할 수 있도록 합니다.

---

## 4. 적용 대상(Applicability)
- 추상 개념과 구현을 독립적으로 확장하고 싶을 때  
- 플랫폼/디바이스별 구현을 분리하고 싶을 때  
- 다차원적인 상속 구조(기능 × 구현)가 생기려고 할 때

---

## 5. 구조(Structure)

```

   (추상화 계층)
+-------------------------+
|      Abstraction        |
+-------------------------+
| - impl: Implementor     |
+-------------------------+
| + operation()           |
+-------------------------+
           ^
           |
+--------------------------+
|   RefinedAbstraction     |
+--------------------------+
| + operation() 확장       |
+--------------------------+

   (구현 계층)
+--------------------------+
|      Implementor         |<<interface>>
+--------------------------+
| + operationImpl()        |
+--------------------------+
      ^               ^
      |               |
+----------------+  +-------------------+
|ConcreteImplA   |  |ConcreteImplB      |
+----------------+  +-------------------+

(Abstraction 은 구현체 인터페이스(Implementor)에만 의존,
구체 구현은 ConcreteImplementorA/B 등이 맡음)

```

---

## 6. 구성 요소(Participants)
- **Abstraction**: 클라이언트가 사용하는 추상 인터페이스  
- **RefinedAbstraction**: Abstraction의 구체 기능 확장  
- **Implementor**: 실제 구현을 위한 인터페이스  
- **ConcreteImplementor**: 실제 플랫폼/디바이스/방식에 대한 구현

---

## 7. 협동(Collaborations)
- Abstraction은 Implementor 인터페이스에만 의존  
- 실제 구현은 ConcreteImplementor가 담당  
- 런타임에 Abstraction과 ConcreteImplementor를 조합하여 다양한 구성을 만들 수 있음

---

## 8. 결과(Consequences)
### 장점
- 추상화와 구현의 독립적인 확장  
- 클래스 폭발 방지  
- 런타임에 구현체 교체 가능

### 단점
- 계층이 하나 더 생겨 구조가 복잡해짐

---

## 9. 구현(Implementation)
- 인터페이스/추상 클래스 조합  
- 구현체를 생성자나 setter로 주입  
- 보통 DI 컨테이너와 함께 쓰면 유리

---

## 10. 샘플 코드(리모컨 – TV 예제)

```java
public interface TV {
    void on();
    void off();
}

public class SamsungTV implements TV {
    public void on() { System.out.println("Samsung TV ON"); }
    public void off() { System.out.println("Samsung TV OFF"); }
}

public abstract class RemoteControl {
    protected TV tv;
    protected RemoteControl(TV tv) { this.tv = tv; }

    public void turnOn() { tv.on(); }
    public void turnOff() { tv.off(); }
}

public class AdvancedRemote extends RemoteControl {
    public AdvancedRemote(TV tv) { super(tv); }
    public void mute() { System.out.println("무음 처리"); }
}
```

## 11. 사용 예(Known Uses)
- JDBC 드라이버(인터페이스 vs 구현체)
- GUI 툴킷의 플랫폼별 구현
- 그래픽 API 추상화(OpenGL vs DirectX 등)

## 12. 연관 패턴(Related Patterns)
- 어댑터 패턴: 기존 인터페이스를 새 인터페이스에 맞추는 것
- 추상 팩토리: 구현체 생성을 책임질 수 있음
- 전략 패턴: 알고리즘 교체에 더 가깝고, 브리지는 계층 분리에 초점

---

# 빌더 패턴(Builder Pattern)

## 1. 패턴 이름과 종류
- 이름: 빌더 패턴(Builder Pattern)
- 종류: 생성(Creational) 패턴

---

## 2. 용도(Intent)
복잡한 객체의 생성 과정을 단계별로 캡슐화하여  
같은 생성 과정으로 서로 다른 표현(객체)을 만들 수 있게 하는 패턴입니다.

---

## 3. 동기(Motivation)
예: 옵션이 꽤 많은 복잡한 객체(예: 복잡한 피자, 문서, HTTP 요청 등)를 생성할 때  
- 생성자 인자가 너무 많아짐(텔레스코핑 생성자 문제)  
- 가독성이 떨어지고, 실수하기 쉬움  
빌더 패턴을 통해 **단계별 설정 → 최종 build()** 형태로 직관적인 생성이 가능합니다.

---

## 4. 적용 대상(Applicability)
- 복잡한 객체를 읽기 좋은 형태로 만들고 싶을 때  
- 생성 시 필수/선택 인자가 많을 때  
- 동일한 생성 절차를 통해 여러 객체 구성을 만들 때

---

## 5. 구조(Structure)

```

(전통적인 GoF 형태 – Director 포함)

+---------------------+
|      Director       |
+---------------------+
| - builder: Builder  |
+---------------------+
| + construct()       |
+---------------------+
          |
          v
+---------------------------+
|          Builder          |<<interface>>
+---------------------------+
| + buildPartA()            |
| + buildPartB()            |
| + getResult(): Product    |
+---------------------------+
           ^
           |
+---------------------------+
|      ConcreteBuilder      |
+---------------------------+
| - product: Product        |
| + buildPartA()            |
| + buildPartB()            |
| + getResult()             |
+---------------------------+
           |
           v
+---------------------------+
|          Product          |
+---------------------------+

(실무에서는 Director 없이 Builder 를 바로 사용하는 경우도 많음)

```

---

## 6. 구성 요소(Participants)
- **Builder 인터페이스**: 제품 생성 단계를 정의  
- **ConcreteBuilder**: 구체적인 필드 설정과 `build()` 구현  
- **Product**: 최종 생성될 객체  
- **Director(선택)**: Builder를 사용해 객체를 생성하는 순서를 관리

---

## 7. 협동(Collaborations)
- Client는 Builder(또는 Director)를 사용해 객체 생성 절차를 진행  
- Product는 Builder 내부에서 완성되어 `build()`로 반환됨

---

## 8. 결과(Consequences)
### 장점
- 생성 코드의 가독성 향상  
- 불변 객체(Immutable Object) 생성에 유리  
- 필수/선택 인자를 명확히 구분 가능

### 단점
- 클래스 수 증가  
- 단순한 객체에는 과한 패턴

---

## 9. 구현(Implementation)
- 메서드 체이닝(fluent API) 방식으로 사용  
- Java/Kotlin에서 Lombok, data class, DSL 등과 잘 어울림

---

## 10. 샘플 코드(간단 피자 빌더)

```java
public class Pizza {
    private final String dough;
    private final String topping;
    private final boolean cheese;

    private Pizza(Builder builder) {
        this.dough = builder.dough;
        this.topping = builder.topping;
        this.cheese = builder.cheese;
    }

    public static class Builder {
        private String dough;
        private String topping;
        private boolean cheese;

        public Builder dough(String dough) {
            this.dough = dough;
            return this;
        }

        public Builder topping(String topping) {
            this.topping = topping;
            return this;
        }

        public Builder cheese(boolean cheese) {
            this.cheese = cheese;
            return this;
        }

        public Pizza build() {
            return new Pizza(this);
        }
    }
}
```

## 11. 사용 예(Known Uses)
- Java의 StringBuilder
- Lombok의 @Builder
- HTTP 클라이언트의 Request Builder

## 12. 연관 패턴(Related Patterns)
- 추상 팩토리: 제품군 생성에 초점, 빌더는 단계별 생성에 초점
- 프로토타입 패턴: 기존 객체 복제 vs 새로 조립
- 팩토리 메서드: 단일 메서드 생성 vs 빌더의 단계 생성

---

# 책임 연쇄 패턴(Chain of Responsibility Pattern)

## 1. 패턴 이름과 종류
- 이름: 책임 연쇄 패턴(Chain of Responsibility Pattern)
- 종류: 행동(Behavioral) 패턴

---

## 2. 용도(Intent)
요청을 처리하는 여러 객체를 체인(연쇄)로 연결해,  
어떤 객체가 그 요청을 처리할지 **동적으로 결정**하도록 하는 패턴입니다.

---

## 3. 동기(Motivation)
예: 로깅(Level별), 권한 체크, 요청 필터링 등  
- INFO는 콘솔만, ERROR는 파일+알람 등  
요청을 처리할 수 있는 핸들러가 여러 개 있을 때,  
요청을 처음부터 끝까지 체인을 타고 내려가면서 처리할지 말지 결정하게 합니다.

---

## 4. 적용 대상(Applicability)
- 여러 핸들러 중 하나 또는 여러 개가 요청을 처리할 수 있을 때  
- 핸들러의 순서를 동적으로 변경할 수 있어야 할 때  
- 클라이언트가 구체적인 핸들러를 몰라도 되게 하고 싶을 때

---

## 5. 구조(Structure)

```

+-------------------+
|      Client       |
+-------------------+
         |
         v
+-------------------+      +-------------------+      +-------------------+
|    Handler(1)     | ---> |    Handler(2)     | ---> |    Handler(3)     |
+-------------------+      +-------------------+      +-------------------+
| - next: Handler   |      | - next: Handler   |      | - next: Handler   |
| + handle(request) |      | + handle(request) |      | + handle(request) |
+-------------------+      +-------------------+      +-------------------+

- 각 Handler 는 요청을 처리하거나, 못 하면 next 로 넘김
- Client 는 체인 맨 앞 Handler 에만 요청 전달

```

---

## 6. 구성 요소(Participants)
- **Handler**: 요청 처리 메서드와 다음 Handler 참조  
- **ConcreteHandler**: 자신이 처리할 수 있으면 처리, 아니면 다음으로 전달  
- **Client**: 체인을 구성하고 첫 Handler에 요청을 보냄

---

## 7. 협동(Collaborations)
- 각 핸들러는 요청을 처리하거나 다음 핸들러로 넘김  
- 체인의 마지막까지 처리자가 없으면 요청이 무시되거나 기본 처리 로직 실행

---

## 8. 결과(Consequences)
### 장점
- 송신자와 수신자의 결합도 감소  
- 핸들러 추가/삭제가 용이  
- 동적으로 체인을 구성 가능

### 단점
- 요청이 끝까지 가도 처리되지 않을 수 있음  
- 디버깅이 어려워질 수 있음

---

## 9. 구현(Implementation)
- 핸들러가 자기 자신과 다음 핸들러의 참조를 가짐  
- 체인을 설정하는 방식(정적/동적)을 잘 설계할 것

---

## 10. 샘플 코드(간단 로그 예제)

```java
public abstract class Logger {
    protected Logger next;

    public Logger setNext(Logger next) {
        this.next = next;
        return next;
    }

    public void log(String level, String message) {
        if (handle(level, message) && next != null) {
            next.log(level, message);
        }
    }

    protected abstract boolean handle(String level, String message);
}

public class InfoLogger extends Logger {
    protected boolean handle(String level, String message) {
        if ("INFO".equals(level)) {
            System.out.println("INFO: " + message);
        }
        return true; // 다음으로 넘길지 여부
    }
}
```

## 11. 사용 예(Known Uses)
- Servlet Filter 체인
- Spring Security FilterChain
- GUI 이벤트 전파

## 12. 연관 패턴(Related Patterns)
- 데코레이터 패턴: 구조적으로 비슷하지만, 책임연쇄는 “다음으로 넘긴다”는 의미가 강함
- 중재자 패턴: 중앙에서 제어 vs 체인으로 전달

---

# 플라이웨이트 패턴(Flyweight Pattern)

## 1. 패턴 이름과 종류
- 이름: 플라이웨이트 패턴(Flyweight Pattern)
- 종류: 구조(Structural) 패턴

---

## 2. 용도(Intent)
대량의 작은 객체를 효율적으로 공유하여  
메모리 사용을 줄이는 패턴입니다.

---

## 3. 동기(Motivation)
예: 텍스트 에디터  
- 문서 내의 글자 수는 수천~수만 개  
- 각 글자마다 폰트, 크기, 스타일 등 동일한 정보가 반복됨  
공유 가능한 정보(내부 상태)와 개별 위치 정보(외부 상태)를 분리하면  
내부 상태는 객체 하나로 공유하고, 외부 상태만 별도로 관리할 수 있습니다.

---

## 4. 적용 대상(Applicability)
- 매우 많은 수의 객체가 필요할 때  
- 객체의 대부분 상태가 공유 가능할 때  
- 메모리 사용을 최적화해야 할 때

---

## 5. 구조(Structure)

```

             uses                          shared
+----------------------+           +----------------------+
|        Client        |---------> |      Flyweight       |<<interface>>
+----------------------+           +----------------------+
| - extrinsicState    |           | + operation(exState) |
+----------------------+           +----------------------+
                                   ^                ^
                                   |                |
                           +----------------+  +------------------+
                           |Concrete        |  |Concrete          |
                           |FlyweightA      |  |FlyweightB        |
                           +----------------+  +------------------+

                        (풀/캐시)
                     +----------------------+
                     |  FlyweightFactory    |
                     +----------------------+
                     | + getFlyweight(key)  |
                     +----------------------+

- intrinsic state: Flyweight 내부에 저장되는 공유 상태
- extrinsic state: Client 가 외부에서 넣어주는 개별 상태

```

---

## 6. 구성 요소(Participants)
- **Flyweight**: 공유 가능한 객체의 인터페이스  
- **ConcreteFlyweight**: 실제 공유 객체  
- **FlyweightFactory**: Flyweight 인스턴스를 생성/캐시  
- **Client**: 외부 상태를 관리하며 Flyweight에 전달

---

## 7. 협동(Collaborations)
- Client는 Factory를 통해 Flyweight를 얻고,  
  필요한 외부 상태를 넣어 `operation()` 호출  
- Factory는 동일한 내부 상태에 대해서는 언제나 같은 Flyweight를 반환

---

## 8. 결과(Consequences)
### 장점
- 메모리 사용량 크게 감소  
- 공유 객체 재사용

### 단점
- 코드 복잡도 증가  
- 외부 상태 관리가 어려울 수 있음

---

## 9. 구현(Implementation)
- FlyweightFactory에서 캐싱(Map 등) 사용  
- 내부/외부 상태를 명확히 구분  
- 스레드 안전하게 관리할 필요가 있을 수 있음

---

## 10. 샘플 코드(간단 캐릭터 플라이웨이트)

```java
public interface Glyph {
    void draw(int x, int y);
}

public class CharacterGlyph implements Glyph {
    private char c; // 내부 상태

    public CharacterGlyph(char c) { this.c = c; }

    public void draw(int x, int y) {
        System.out.println("Draw '" + c + "' at (" + x + "," + y + ")");
    }
}

public class GlyphFactory {
    private Map<Character, Glyph> pool = new HashMap<>();

    public Glyph getGlyph(char c) {
        return pool.computeIfAbsent(c, CharacterGlyph::new);
    }
}
```

## 11. 사용 예(Known Uses)
- 텍스트 렌더링 엔진
- IDE에서 심볼/토큰 관리
- 그래프 노드/타일맵에서 동일한 타일 공유

## 12. 연관 패턴(Related Patterns)
- 싱글턴 패턴: 단일 인스턴스 vs 다수 공유 인스턴스
- 팩토리 패턴: FlyweightFactory 구현에 사용
