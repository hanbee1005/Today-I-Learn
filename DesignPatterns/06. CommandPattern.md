# 커맨드 패턴 (Command Pattern)

## 1. 패턴 이름과 종류
- 이름: 커맨드 패턴(Command Pattern)
- 종류: 행동(Behavioral) 패턴

---

## 2. 용도(Intent)
요청을 객체로 캡슐화하여, 서로 다른 요청을 큐잉하거나 로그를 남기고  
실행 취소(undo) 기능을 제공할 수 있도록 하는 패턴입니다.

---

## 3. 동기(Motivation)
리모컨(Remote Control) 예제를 보면, 버튼마다 “전등 켜기”, “선풍기 끄기”, “문 열기” 등의 명령이 필요합니다.  
이 명령들을 단순 if-else로 처리하면 책임이 뒤섞이고 확장이 불편해집니다.  
커맨드 패턴은 **요청을 객체화**하여 리모컨과 실제 기능 사이를 분리해줍니다.

---

## 4. 적용 대상(Applicability)
- 실행 취소, 재실행 기능이 필요할 때  
- 실행할 동작을 파라미터화하고 싶을 때  
- 요청을 큐에 넣고 다른 시점에 실행하고 싶을 때  
- 요청을 로그로 남기고 재실행하고 싶을 때

---

## 5. 구조(Structure)

```

+-------------------+
|      Client       |
+-------------------+
        |
        | creates & sets
        v
+--------------------+        +--------------------+
|      Invoker       |        |      Command       |<<interface>>
+--------------------+        +--------------------+
| - command: Command |------->| + execute()        |
| + setCommand(c)    |        +--------------------+
| + pressButton()    |                   ^
+--------------------+                   |
                                         |
                                +----------------------+
                                |   ConcreteCommand    |
                                +----------------------+
                                | - receiver: Receiver |
                                | + execute()          |
                                +----------------------+
                                           |
                                           v
                                   +--------------+
                                   |   Receiver   |
                                   +--------------+
                                   | + action()   |
                                   +--------------+

```

---

## 6. 구성 요소(Participants)
- **Command 인터페이스**: 단일 메서드 `execute()`를 정의  
- **ConcreteCommand**: 실제 실행할 로직을 가지고 Receiver에 위임  
- **Receiver**: 실제 작업을 수행  
- **Invoker**: 커맨드를 실행하는 주체  
- **Client**: ConcreteCommand와 Receiver를 조합함

---

## 7. 협동(Collaborations)
Invoker는 Command 인터페이스만 알고 있고,  
ConcreteCommand는 Receiver를 호출하여 실제 작업을 수행합니다.  
Client는 어떤 커맨드를 사용할지 결정합니다.

---

## 8. 결과(Consequences)
### 장점
- 요청을 객체로 캡슐화하여 확장성 증가  
- 실행 취소 기능 구현 가능  
- Invoker와 Receiver의 강한 결합 제거  
- 요청을 큐/로그로 관리 가능

### 단점
- 커맨드 객체 수가 많아질 수 있음

---

## 9. 구현(Implementation)
- Command는 인터페이스로 구성하고 `execute()` 또는 `undo()` 제공  
- Invoker는 Command 객체를 보관하고 실행  
- Receiver는 실제 로직 담당

---

## 10. 샘플 코드(리모컨 예제)

```java
public interface Command {
    void execute();
}

public class Light {
    public void on() { System.out.println("Light On"); }
    public void off() { System.out.println("Light Off"); }
}

public class LightOnCommand implements Command {
    private Light light;

    public LightOnCommand(Light light) { this.light = light; }

    public void execute() { light.on(); }
}

public class RemoteControl {
    private Command slot;

    public void setCommand(Command command) { slot = command; }

    public void pressButton() { slot.execute(); }
}
```

## 11. 사용 예(Known Uses)
- GUI 버튼 클릭 처리
- 매크로 시스템
- 스프링의 이벤트 처리 구조 일부
- 작업 큐 시스템

## 12. 연관 패턴(Related Patterns)
- 전략 패턴: 알고리즘 교체가 목적
- 퍼사드 패턴: Invoker처럼 느슨하게 연결
- 반복자 패턴: 커맨드를 반복해 실행할 때 결합됨
