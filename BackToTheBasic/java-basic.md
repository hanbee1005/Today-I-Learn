# Part 1. Java
Java 언어의 기본과 객체 지향 프로그래밍 기초에 대한 내용을 정리하였습니다. 🧱

## 변수
- Primitive Type / Reference Type
  + 기본형(Primitive Type) : ```int```, ```long```, ```double```, ```boolean```처럼 변수에 사용할 값을 직접 넣을 수 있는 데이터 타입
  + 참조형(Reference Type) : 객체(```Student```), 배열(```int[]```)와 같이 데이터에 접근하기 위한 참조(주소)를 저장하는 데이터 타입
  + ***String*** : String은 클래스로 참조형이지만 기본형처럼 문자값을 바로 대입
- 계산
  + 기본형은 연산이 가능하지만 참조형은 직접 연산이 불가능
- 대입
  + 자바에서 대입은 **항상 변수에 값을 복사해서 저장**하는 것!!!
  + 기본형이면 변수에 들어있는 실제 값을 복사해서 대입
    ```java
    int a = 10;
    int b = a;
    // 결과 a = 10, b = 10
    ```
  + 참조형이면 변수에 들어있는 참조값을 복사해서 대입
    ```java
    Student s1 = new Student();
    Student s2 = s1;
    // 결과 s1 = x001, s2 = x001 -> 객체는 하나 
    ```
- 메서드 호출
  + 기본형은 메서드 내부에서 파라미터의 값을 변경해도 호출자의 변수 값에는 영향이 없음
  + 참조형은 메서드 내부에서 파라미터로 전달된 객체의 멤버 변수를 변경하면 호출자의 객체도 변경됨
- 초기화
  + 멤버 변수(필드) : 자동 초기화, 인스턴스 생성 시 기본값(숫자(int)는 0, boolean은 false, 참조형은 null)으로 초기화되거나 개발자가 수동으로 초기화할 수 있음
  + 지역 변수 : 수동 초기화, 메서드 내에서 사용되는 지역 변수는 반드시 수동으로 초기화 후 사용해야 함
- null
  + 참조형 변수에 아직 가리키는 대상이 없는 경우
  + 아무도 참조하지 않는 대상은 GC에 의해 정리됨
  + ```NullPointerException```
    - null 에 .(dot)을 찍었을 때 발생
- 제네릭 (Generic)
  + 타입 이레이저
    - 컴파일 단계에서 사용하고 컴파일 이후에는 Object로 변경되고 캐스팅이 필요한 경우 해당하는 타입에 맞게 캐스팅도 해줌
    - 타입 매개변수 제한이 있는 경우 상위 타입으로 변경
    - 한계: 컴파일 이후에는 타입 정보가 존재하지 않게 때문에 런타임 시에 타입을 활용하는 코드는 작성할 수 없다.
      + ```x instanceof T``` 와 같은 코드가 있을 때 T가 Object 로 변환되어 항상 참이기 때문에 허용하지 않는다.
      + ```new T()``` 와 같은 코드가 있을 때 T가 Object로 변환되어 개발자의 의도와 달라지기 때문에 허용하지 않는다.

## 메모리 구조
- 구조
  + 메서드 영역 : 프로그램을 실행하는데 필요한 공통 데이터를 관리 (프로그램 모든 영역 공유)
    - 클래스 정보 : 클래스 실행 코드(바이트 코드), 필드, 메서드와 생성자 코드 등
    - static : static 변수
    - 런타임 상수 풀 : 프로그램을 실행하는데 필요한 공통 리터럴 상수
  + 스택 영역 : 실제 프로그램이 실행되는 영역으로 메서드를 실행할 때마다 하나씩 쌓임 (쓰레드마다 할당)
    - 지역 변수, 중간 연산 결과, 메서드 호출 정보 등
  + 힙 영역 : 객체(인스턴스)와 배열이 생성되는 영역 (프로그램 모든 영역 공유)
    - GC의 대상이 되는 영역
    - 객체의 필드에 대한 영역은 새로 생성되지만 메서드 코드는 메서드 영역에 있는 공통 코드를 불러 실행
- static
  + 인스턴스 변수 : static이 붙지 않은 멤버 변수로 인스턴스를 생성할 때 같이 생성 및 사용
  + 클래스 변수 : static이 붙은 멤버 변수로 자바 프로그램 실행 시 1회 생성 후 공용으로 사용 (= 정적 변수, static 번수)
  + 변수와 생명 주기
    - 지역 변수(매개변수 포함) : 스택 영역에 있는 스택 프레임 안에 보관되므로 메서드 종료 시 같이 종료
    - 인스턴스 변수 : 힙 영역에 보관되므로 GC의 대상이 될 때까지 생존
    - 클래스 변수 : 메서드 영역 내 static 영역에 보관되므로 JVM이 로딩될 떄 생성되어 종료될 때까지 생존
  + 클래스 메서드(= 정적 메서드)는 객체 생성 없이 클래스명으로 접근 가능하고 인스턴스 메서드는 객체를 생성해서 접근
  + 정적 메서드 사용법
    - static 메서드는 static 만 사용 가능
    - 반대로 모든 곳에서 static 메서드 호출 가능 (접근 제어자 허용 범위 내에서)
- JVM
- GC

## 클래스
- 왜 필요한가?
  + 하나의 개념을 만들고 연관된 속성을 같이 관리하기 위해 사용
- 용어
  + 클래스 : 사용자 정의 타입을 만들기 위한 설계도
  + 인스턴스(= 객체) : 실제 메모리에 만들어진 실체
- 구성
  + 생성자
  + 멤버변수, 필드
  + 메서드
- 상속
  + 다중 상속 불가 (다이아몬드 문제)
  + 메모리 구조
    - 상속 관계의 객체를 생성하면 그 내부에는 부모와 자식이 모두 생성
    - 상속 관계의 객체를 호출할 때, 대상 타입을 지정해야 한다. 이때 호출자의 타입을 통해 대상 타입을 찾는다.
    - 현재 타입에서 기능을 찾지 못한 경우 상위 부모 타입에서 기능을 찾아서 실행한다. 기능을 찾지 못하면 컴파일 오류가 발생
  + 오버라이딩
    - 부모에게 상속 받은 기능을 자식에서 새로 재정의하는 것
    - 조건
      + 메서드 이름이 같아야 한다.
      + 메서드 파라미터 타입, 순서, 개수가 같아야 한다.
      + 반환 타입이 같아야 한다.
      + 접근 제어자는 상위 메서드보다 제한적일 수 없다.
      + 예외는 상위 클래스의 메서드보다 더 많은 체크 예외를 throw 로 선언할 수 없다.
      + static, final, private 은 불가하다.
      + 생성자는 오버라딩할 수 없다.
  + super
    - 상속 관계 사용 시 자식 클래스 생성자에서 부모 클래스의 생성자를 반드시 호출해야 한다.
- 다형성
  + 프로그래밍에서 다형성은 하나의 객체가 여러 타입의 객체로 취급될 수 있는 능력을 의미
  + 다형적 참조
    - 부모 타입의 변수가 자식 타입 인스턴스를 참조할 수 있다. ```Parent parent = new Child();```
    - 부모 방향에서 자식 방향으로 내려올 수 없어서 반대로는 불가 -> 다운 캐스팅을 통해 호출 가능
    - 다운 캐스팅 주의점
      + 업캐스팅은 자식 인스턴스가 생성될 때 부모 인스턴스도 반드시 생성되기 때문에 문제가 없지만
      + 부모 타입으로 처음 생성된 인스턴스를 다운 캐스팅 하려고 하면 인스턴스가 존재하지 않는 자식 타입으로 다운 캐스팅 하면 ClassCastException이 발생할 수 있다.
    - instanceof : 변수에 할당된 인스턴스가 무엇인지 확인하는 키워드 (오른쪽에 있는 타입에 왼쪽에 있는 인스턴스의 타입이 들어갈 수 있으면 true, 안되면 false)
  + 메서드 오버라이딩
    - **오버라이딩된 메서드가 항상 우선권을 가진다.**
    - 멤버 변수는 오버라이딩 x, 메서드만 오버라이딩 가능
  + 활용
    - 메서드 파라이터 등으로 받을 때 상위 클래스를 사용하면 중복 제거를 하고 오버라이딩된 하위 클래스의 메서드를 사용할 수 있음
- 추상 클래스
  + abstract 키워드가 붙어 실제 인스턴스를 생성할 수 없는 개념만 제공하는 클래스
  + 추상 메서드
    - abstract 키워드가 붙고 메서드 바디가 없는 메서드
    - 추상 메서드가 하나라도 있는 클래스는 추상 클래스로 선언해야 한다.
    - 추상 메서드는 상속 받은 자식 클래스가 반드시 오버라이딩 해서 사용해야 한다.
  + 순수 추상 클래스 = 모든 메서드가 다 추상 메서드인 클래스
    - 인스턴스를 생성할 수 없다.
    - **상속 시 자식은 모든 메서드를 오버라이딩 해야 한다.**
    - 주로 다형성을 위해 사용된다.
    - == 인터페이스
- 인터페이스
  + 메서드는 모두 public abstract 이다. (생략 가능)
  + 다중 구현 (다중 상속)이 가능하다.
  + 멤버 변수는 public static final 이 포함되어 있다고 생각한다.
  + 클래스, 추상 클래스, 인터페이스 모두 프로그램 코드, 메모리 구조상 똑같다. 모두 자바에서는 ```.class```로 다루어진다. 인터페이스를 작성할 때도 ```.java```에 정의한다.
  + 인터페이스를 사용하면 좋은 장점
    - **제약** : 인터페이스의 메서드를 반드시 구현해야한다는 제약을 줄 수 있다. 순수 추상 클래스를 만들면 누군가 다른 기능을 넣을 수 있는데 인터페이스는 이를 차단할 수 있다.
      + ```default, private```메서드가 등장하였지만 이는 주의해서 사용해야 한다.
    - 다중 상속 : 인터페이스는 여러 개 구현할 수 있다. 클래스는 하나만 상속 받을 수 있다.
- 중첩 클래스
  + 분류
    - non-static
      + inner class (내부 클래스) -> 인스턴스 변수와 같은 위치
      + local class (지역 클래스) -> 지역 변수와 같은 위치
      + anonymous class (익명 클래스) -> 지역 변수와 같은 위치
    - static
      + 정적 중첩 클래스 -> 정적 변수와 같은 위치
  + 용어 정리
    - 중첩(Nested): 어떤 다른 것이 내부에 위치하거나 포함되는 구조적 관계
      + 정적 중첩 클래스는 바깥 클래스 안에 있지만 전혀 다른 클래스
    - 내부(Inner): 나의 내부에 있는 나를 구성하는 요소
      + 내부 클래스는 바깥 클래스 안에 있으면서 바깥 클래스의 구성 요소
  + 사용 시점
    - 내부 클래스를 포함한 모든 중첩 클래스는 특정 클래스가 다른 하나의 클래스 안에서만 사용되거나, 둘이 아주 긴밀하게 연결되어 있는 특별한 경우에만 사용해야 함
    - 외부의 여러 클래스가 특정 중첩 클래스를 사용한다면 중첩 클래스로 만들면 안된다.
  + 사용 이유
    - 논리적 그룹화: 특정 클래스가 다른 하나의 클래스 안에서만 사용되는 경우 해당 클래스 안에 포함되는 것이 논리적으로 더 그룹화가 됨. 패키지를 열었을 때 다른 곳에서 사용될 필요가 없는 중첩 클래스가 외부에 노출되지 않는 장점이 있다.
    - 캡슐화: 중첩 클래스는 바깥 클래스의 ```private``` 멤버에 접근할 수 있다. 이렇게 해서 둘을 긴밀하게 연결하고 불필요한 ```public``` 메서드를 제거할 수 있다.
  + 지역 변수 캡처
    - **지역 클래스가 접근하는 지역 변수의 값은 변경하면 안된다.**
    - 지역 변수의 생명 주기는 보통 짧고, 인스턴스의 생명 주기가 더 길다.
    - 자바는 인스턴스를 생성하는 시점에 필요한 지역 변수를 모두 복사해서 생성한 인스턴스에 함께 넣어둔다. 이 과정을 변수 캡처(Capture)라고 한다.
    - 따라서 지역변수를 인스턴스에 복사하여 넣기 때문에 값이 변경되면 안된다. -> 사실상 final
      + 지역 변수의 값을 변경하면 인스턴스에 캡처한 변수의 값도 변경해야 한다.
      + 반대로 인스턴스에 있는 캡처 변수의 값을 변경하면 해당 지역 변수의 값도 다시 변경해야 한다.
      + 개발자 입장에서 보면 예상 못한 곳에서 값이 변경될 수 있다. 이는 디버깅을 어렵게 한다.
      + 지역 변수의 값과 인스턴스에 있는 캡처 변수의 값을 서로 동기화 해야 하는데, 멀티 쓰레드 상황에서 이런 동기화는 매우 어렵고 성능에 나쁜 영향을 줄 수 있다.
      + 따라서 문제를 근본적으로 차단한다.
      
## Object
- 자바에서 Object 클래스가 최상위 부모 클래스인 이유
  + 공통 기능 제공
    - 객체의 정보를 제공```toString()```하고 객체가 같음을 비교```equals()```하고 객체가 가진 클래스 정보```getClass()```를 제공하는 등의
    - 공통 기능을 제공함으로써 일관성 있고 단순한 프로그래밍이 가능하게 한다.
  + 다형성의 기본 구현
    - 모든 객체를 참조할 수 있다. 따라서 타입이 다른 객체를 어딘가에 보관해야 한다면 Object를 사용할 수 있다.
- equals
  + 동일성(Identity): ```==``` 연산자를 사용해서 두 객체의 참조가 동일한 객체를 가리키고 있는지 확인 (완전히 같은 것, 물리적으로 같은 것)
  + 동등성(Equality): ```equals()``` 메서드를 사용해서 두 객체가 논리적으로 동등한지 확인 (객체마다 동등성의 정의는 다름)
  + Object의 equals는 내부적으로 == 비교를 하기 때문에 필요한 경우에 오버라이딩해서 사용
- Class 클래스
  + 주요 기능
    - 타입 정보 얻기: 클래스의 이름, 슈퍼클래스, 인터페이스, 접근제어자 등과 같은 정보를 조회할 수 있다.
    - 리플랙션: 클래스에 정의된 메서드, 필드, 생성자 등을 조회하고 이들을 통해 객체 인스턴스를 생성하거나 메서드를 호출하는 등의 작업을 할 수 있다.
    - 동적 로딩 생성: ```Class.forName()``` 메서드를 사용하여 클래스를 동적으로 로드하고, ```newInstance()``` 메서드를 통해 새로운 인스턴스를 생성할 수 있다.
    - 애노테이션 처리: 클래스에 적용된 애노테이션(annotation)을 조회하고 처리하는 기능을 제공한다.

## 불변 객체
- 여러 변수가 하나의 객체를 공유하는 것을 막을 수 있는 방법이 없기 때문에
- 문제의 직접적인 원인인 값을 변경하는 것을 막는 객체
- 장점
  + 캐시 안정성
  + 멀티 쓰레드 안정성
  + 엔티티의 값 타입

## 객체지향
- 객체지향 vs 절차지향
  + 절차지향: 실행 순서를 중요하게 생각하는 방식으로 **어떻게**를 중심으로 한 프로그래밍
    - 한계: 데이터와 기능이 분리되어 있어 관리 포인트 증가
  + 객체지향: 객체를 중요하게 생각하는 방식으로 **무엇을**에 초점을 맞춘 프로그래밍
  + 둘의 큰 차이는 데이터(필드)와 해당 데이터에 대한 처리(메서드)가 객체 내부에 포함되어 있는지, 분리되어 있는지
- 캡슐화
  + 속성과 기능이 마치 하나의 캡슐에 쌓여 있는 것처럼 묶여져서 외부로 제공
  + 코드 가독성이 높아지고 변경에도 용이
  + 접근 제어자
    - private: 모든 외부 호출을 막음
    - default(package-private): 같은 패키지 안에서 호출은 허용 
    - protected: 같은 패키지 안에 있거나 다른 패키지라도 상속 관계 호출 허용
    - public: 모든 외부 호출 허용
  + 데이터(속성)은 숨겨라 -> 메서드를 통해 접근
  + 메서드를 숨겨라 -> 꼭 필요한 메서드만 제공
- SOLID
  + SRP(Single Responsibility Principle: 단일 책임 원칙)
    - 하나의 클래스는 하나의 책임을 가진다는 것으로 변경에 대한 파급이 적은 것이 핵심
  + OCP(Open Close Principle: 개방 폐쇄 원칙)
    - 다형성을 활용하여 확장에는 열려있고 변경에는 닫혀있게 만드는 것이 핵심
    - 다형성을 사용해도 객체를 생성하고 연관 관계를 맺어주는 별도의 생성자가 필요
  + LSP(Liskov Substitution Principle: 리스코프 치환 원칙)
    - 컴파일을 넘어 규약을 맞추고 하위 타입의 인스턴스로 변경이 가능해야 함
  + ISP(Interface Segregation Principle: 인터페이스 분리 원칙)
    - 특정 클라이언트를 위한 인터페이스 여러개가 범위 인터페이스보다 나음
  + DIP(Dependency Inversion Principle: 의존성 역전의 원칙)
    - 추상화에 의존하고 구체화에 의존하면 안된다는 것으로 역할에 의존하고 구현에 의존하지 말아야 한다는 것
   
## 예외
- 종류
  + ```Object```: 자바에서 기본형을 제외한 모든 것은 객체이고 예외도 객체다. 따라서 예외의 최상위 부모 역시 ```Object```다.
  + ```Throwable```: 최상위 예외로 하위에 ```Error```와 ```Exception```이 있다.
  + ```Error```: 메모리 부족이나 심각한 시스템 오류와 같이 애플리케이션에서 복구가 불가능한 시스템 예외이다. 애플리케이션 개발자는 이 예외를 잡으려고 해서는 안된다.
  + ```Exception```: 체크 예외로 애플리케이션 로직에서 사용할 수 있는 사실상 최상위 예외다. ```Eeception```과 그 하위 예외들은 모두 컴파일러가 체크하는 예외다. 단, ```RuntimeException```은 컴파일러가 체크하지 않는다.
  + ```RuntimeException```: 컴파일러가 체크하지 않는 언체크 예외로 그 자식 예외들도 모두 언체크 예외다.
- checked vs unchecked
  + 체크 예외는 발생한 예외를 개발자가 명시적으로 처리해야 한다. 그렇지 않으면 컴파일 오류가 발생한다. 언체크 예외는 개발자가 명시적으로 처리하지 않아도 된다.
  + checked 예외 장단점
    - 장점: 개발자가 실수로 예외를 누락하지 않도록 컴파일러를 통해 문제를 잡아주는 훌륭한 안전장치이다. 
    - 단점: 하지만 개발자가 모든 체크 예외를 잡거나 던지도록 해야하기 때문에 번거롭다.
  + unchecked 예외 장단점
    - 장점: 신경 쓰고 싶지 않은 언체크 예외를 무시할 수 있다. 언체크 예외는 throws를 생략할 수 있기 때문이다.
    - 단점: 언체크 예외는 개발자가 실수로 예외를 누락할 수 있다.
   
## 버전 별 참고
- Java 8
- record
  + Java 14 버전에 나와 17에 정식으로 채택
  + request,response 등 한번 생성되면 변경이 없이 데이터만 전달하는 경우 기본적으로 작성해야 하는 코드들을 줄일 수 있도록 개발된 자료 구조
  + 모든 필드가 private final 로 되어 있고
- toList()
  + Java 8 때 collect(Collectors.toList()) 사용이 가능했지만 반환 리스트가 가변적이라 데이터를 더 추가할 수 있었고 NULL 값을 넣을 수 있도록 허용
  + Java 10 때 Collectors.toUnmodifiableList() 가 나왔고 반환 리스트가 불변이지만 NULL을 허용하지 않아 NULL 이 들어간 경우 NPE 발생
  + Java 16 때 Stream.toList() 가 나왔고 이는 반환 리스트가 불변이고 NULL을 허용

## 참고
- [김영한의 실전 자바 - 기본편](https://www.inflearn.com/course/%EA%B9%80%EC%98%81%ED%95%9C%EC%9D%98-%EC%8B%A4%EC%A0%84-%EC%9E%90%EB%B0%94-%EA%B8%B0%EB%B3%B8%ED%8E%B8/dashboard)
- [김영한의 실전 자바 - 중급편 1](https://www.inflearn.com/course/%EA%B9%80%EC%98%81%ED%95%9C%EC%9D%98-%EC%8B%A4%EC%A0%84-%EC%9E%90%EB%B0%94-%EC%A4%91%EA%B8%89-1)
- [김영한의 실전 자바 - 중급편 2](https://www.inflearn.com/course/%EA%B9%80%EC%98%81%ED%95%9C%EC%9D%98-%EC%8B%A4%EC%A0%84-%EC%9E%90%EB%B0%94-%EC%A4%91%EA%B8%89-2)
