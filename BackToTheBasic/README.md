# Back to the BASIC
해당 디렉토리는 기본이 되는 언어, 프레임워크 등에 대해 다시 공부한 내용을 정리하는 임시 디렉토리입니다. 기본부터 탄탄하게! 🧱

- 기간(3개월): 2024-03 ~ 2024-05

## Part 1. Java
### 변수
- Primitive Type / Reference Type
  + 기본형(Primitive Type) : ```int```, ```long```, ```double```, ```boolean```처럼 변수에 사용할 값을 직접 넣을 수 있는 데이터 타입
  + 참조형(Reference Type) : 객체(```Student```), 배열(```int[]```)와 같이 데이터에 접근하기 위한 참조(주소)를 저장하는 데이터 타입
  + ***String*** : String은 클래스로 참조형이지만 기본형처럼 문자값을 바로 대입
- 계산
  + 기본형은 연산이 가능하지만 참조형은 직접 연산이 불가능
- 대입
  + 자바에서 대입은 **항상 변수에 값을 복사해서 저장**하는 것!!!
  + 기본형이면 변수에 들어있는 실제 값을 복사해서 대입
    ```java
    int a = 10;
    int b = a;
    // 결과 a = 10, b = 10
    ```
  + 참조형이면 변수에 들어있는 참조값을 복사해서 대입
    ```java
    Student s1 = new Student();
    Student s2 = s1;
    // 결과 s1 = x001, s2 = x001 -> 객체는 하나 
    ```
- 메서드 호출
  + 기본형은 메서드 내부에서 파라미터의 값을 변경해도 호출자의 변수 값에는 영향이 없음
  + 참조형은 메서드 내부에서 파라미터로 전달된 객체의 멤버 변수를 변경하면 호출자의 객체도 변경됨
- 초기화
  + 멤버 변수(필드) : 자동 초기화, 인스턴스 생성 시 기본값(숫자(int)는 0, boolean은 false, 참조형은 null)으로 초기화되거나 개발자가 수동으로 초기화할 수 있음
  + 지역 변수 : 수동 초기화, 메서드 내에서 사용되는 지역 변수는 반드시 수동으로 초기화 후 사용해야 함
- null
  + 참조형 변수에 아직 가리키는 대상이 없는 경우
  + 아무도 참조하지 않는 대상은 GC에 의해 정리됨
  + ```NullPointerException```
    - null 에 .(dot)을 찍었을 때 발생

### 메모리 구조
- 구조
  + 메서드 영역 : 프로그램을 실행하는데 필요한 공통 데이터를 관리 (프로그램 모든 영역 공유)
    - 클래스 정보 : 클래스 실행 코드(바이트 코드), 필드, 메서드와 생성자 코드 등
    - static : static 변수
    - 런타임 상수 풀 : 프로그램을 실행하는데 필요한 공통 리터럴 상수
  + 스택 영역 : 실제 프로그램이 실행되는 영역으로 메서드를 실행할 때마다 하나씩 쌓임 (쓰레드마다 할당)
    - 지역 변수, 중간 연산 결과, 메서드 호출 정보 등
  + 힙 영역 : 객체(인스턴스)와 배열이 생성되는 영역 (프로그램 모든 영역 공유)
    - GC의 대상이 되는 영역
    - 객체의 필드에 대한 영역은 새로 생성되지만 메서드 코드는 메서드 영역에 있는 공통 코드를 불러 실행
- static
  + 인스턴스 변수 : static이 붙지 않은 멤버 변수로 인스턴스를 생성할 때 같이 생성 및 사용
  + 클래스 변수 : static이 붙은 멤버 변수로 자바 프로그램 실행 시 1회 생성 후 공용으로 사용 (= 정적 변수, static 번수)
  + 변수와 생명 주기
    - 지역 변수(매개변수 포함) : 스택 영역에 있는 스택 프레임 안에 보관되므로 메서드 종료 시 같이 종료
    - 인스턴스 변수 : 힙 영역에 보관되므로 GC의 대상이 될 때까지 생존
    - 클래스 변수 : 메서드 영역 내 static 영역에 보관되므로 JVM이 로딩될 떄 생성되어 종료될 때까지 생존
  + 클래스 메서드(= 정적 메서드)는 객체 생성 없이 클래스명으로 접근 가능하고 인스턴스 메서드는 객체를 생성해서 접근
  + 정적 메서드 사용법
    - static 메서드는 static 만 사용 가능
    - 반대로 모든 곳에서 static 메서드 호출 가능 (접근 제어자 허용 범위 내에서)
- JVM
- GC

### 클래스
- 왜 필요한가?
  + 하나의 개념을 만들고 연관된 속성을 같이 관리하기 위해 사용
- 용어
  + 클래스 : 사용자 정의 타입을 만들기 위한 설계도
  + 인스턴스(= 객체) : 실제 메모리에 만들어진 실체
- 구성
  + 생성자
  + 멤버변수, 필드
  + 메서드
- 상속
  + 다중 상속 불가 (다이아몬드 문제)
  + 메모리 구조
    - 상속 관계의 객체를 생성하면 그 내부에는 부모와 자식이 모두 생성
    - 상속 관계의 객체를 호출할 때, 대상 타입을 지정해야 한다. 이때 호출자의 타입을 통해 대상 타입을 찾는다.
    - 현재 타입에서 기능을 찾지 못한 경우 상위 부모 타입에서 기능을 찾아서 실행한다. 기능을 찾지 못하면 컴파일 오류가 발생
  + 오버라이딩
    - 부모에게 상속 받은 기능을 자식에서 새로 재정의하는 것
    - 조건
      + 메서드 이름이 같아야 한다.
      + 메서드 파라미터 타입, 순서, 개수가 같아야 한다.
      + 반환 타입이 같아야 한다.
      + 접근 제어자는 상위 메서드보다 제한적일 수 없다.
      + 예외는 상위 클래스의 메서드보다 더 많은 체크 예외를 throw 로 선언할 수 없다.
      + static, final, private 은 불가하다.
      + 생성자는 오버라딩할 수 없다.
  + super
    - 상속 관계 사용 시 자식 클래스 생성자에서 부모 클래스의 생성자를 반드시 호출해야 한다.
- 다형성
  + 프로그래밍에서 다형성은 하나의 객체가 여러 타입의 객체로 취급될 수 있는 능력을 의미
  + 다형적 참조
    - 부모 타입의 변수가 자식 타입 인스턴스를 참조할 수 있다. ```Parent parent = new Child();```
    - 부모 방향에서 자식 방향으로 내려올 수 없어서 반대로는 불가 -> 다운 캐스팅을 통해 호출 가능
    - 다운 캐스팅 주의점
      + 업캐스팅은 자식 인스턴스가 생성될 때 부모 인스턴스도 반드시 생성되기 때문에 문제가 없지만
      + 부모 타입으로 처음 생성된 인스턴스를 다운 캐스팅 하려고 하면 인스턴스가 존재하지 않는 자식 타입으로 다운 캐스팅 하면 ClassCastException이 발생할 수 있다.
    - instanceof : 변수에 할당된 인스턴스가 무엇인지 확인하는 키워드 (오른쪽에 있는 타입에 왼쪽에 있는 인스턴스의 타입이 들어갈 수 있으면 true, 안되면 false)
  + 메서드 오버라이딩
    - **오버라이딩된 메서드가 항상 우선권을 가진다.**
    - 멤버 변수는 오버라이딩 x, 메서드만 오버라이딩 가능
  + 활용
    - 메서드 파라이터 등으로 받을 때 상위 클래스를 사용하면 중복 제거를 하고 오버라이딩된 하위 클래스의 메서드를 사용할 수 있음
- 추상 클래스
  + abstract 키워드가 붙어 실제 인스턴스를 생성할 수 없는 개념만 제공하는 클래스
  + 추상 메서드
    - abstract 키워드가 붙고 메서드 바디가 없는 메서드
    - 추상 메서드가 하나라도 있는 클래스는 추상 클래스로 선언해야 한다.
    - 추상 메서드는 상속 받은 자식 클래스가 반드시 오버라이딩 해서 사용해야 한다.
  + 순수 추상 클래스 = 모든 메서드가 다 추상 메서드인 클래스
    - 인스턴스를 생성할 수 없다.
    - **상속 시 자식은 모든 메서드를 오버라이딩 해야 한다.**
    - 주로 다형성을 위해 사용된다.
    - == 인터페이스
- 인터페이스
  + 메서드는 모두 public abstract 이다. (생략 가능)
  + 다중 구현 (다중 상속)이 가능하다.
  + 멤버 변수는 public static final 이 포함되어 있다고 생각한다.
  + 클래스, 추상 클래스, 인터페이스 모두 프로그램 코드, 메모리 구조상 똑같다. 모두 자바에서는 ```.class```로 다루어진다. 인터페이스를 작성할 때도 ```.java```에 정의한다.
  + 인터페이스를 사용하면 좋은 장점
    - **제약** : 인터페이스의 메서드를 반드시 구현해야한다는 제약을 줄 수 있다. 순수 추상 클래스를 만들면 누군가 다른 기능을 넣을 수 있는데 인터페이스는 이를 차단할 수 있다.
      + ```default, private```메서드가 등장하였지만 이는 주의해서 사용해야 한다.
    - 다중 상속 : 인터페이스는 여러 개 구현할 수 있다. 클래스는 하나만 상속 받을 수 있다.
- 중첩 클래스
  + 분류
    - non-static
      + inner class (내부 클래스) -> 인스턴스 변수와 같은 위치
      + local class (지역 클래스) -> 지역 변수와 같은 위치
      + anonymous class (익명 클래스) -> 지역 변수와 같은 위치
    - static
      + 정적 중첩 클래스 -> 정적 변수와 같은 위치
  + 용어 정리
    - 중첩(Nested): 어떤 다른 것이 내부에 위치하거나 포함되는 구조적 관계
      + 정적 중첩 클래스는 바깥 클래스 안에 있지만 전혀 다른 클래스
    - 내부(Inner): 나의 내부에 있는 나를 구성하는 요소
      + 내부 클래스는 바깥 클래스 안에 있으면서 바깥 클래스의 구성 요소
  + 사용 시점
    - 내부 클래스를 포함한 모든 중첩 클래스는 특정 클래스가 다른 하나의 클래스 안에서만 사용되거나, 둘이 아주 긴밀하게 연결되어 있는 특별한 경우에만 사용해야 함
    - 외부의 여러 클래스가 특정 중첩 클래스를 사용한다면 중첩 클래스로 만들면 안된다.
  + 사용 이유
    - 논리적 그룹화: 특정 클래스가 다른 하나의 클래스 안에서만 사용되는 경우 해당 클래스 안에 포함되는 것이 논리적으로 더 그룹화가 됨. 패키지를 열었을 때 다른 곳에서 사용될 필요가 없는 중첩 클래스가 외부에 노출되지 않는 장점이 있다.
    - 캡슐화: 중첩 클래스는 바깥 클래스의 ```private``` 멤버에 접근할 수 있다. 이렇게 해서 둘을 긴밀하게 연결하고 불필요한 ```public``` 메서드를 제거할 수 있다. 
      
### Object
- 자바에서 Object 클래스가 최상위 부모 클래스인 이유
  + 공통 기능 제공
    - 객체의 정보를 제공```toString()```하고 객체가 같음을 비교```equals()```하고 객체가 가진 클래스 정보```getClass()```를 제공하는 등의
    - 공통 기능을 제공함으로써 일관성 있고 단순한 프로그래밍이 가능하게 한다.
  + 다형성의 기본 구현
    - 모든 객체를 참조할 수 있다. 따라서 타입이 다른 객체를 어딘가에 보관해야 한다면 Object를 사용할 수 있다.
- equals
  + 동일성(Identity): ```==``` 연산자를 사용해서 두 객체의 참조가 동일한 객체를 가리키고 있는지 확인 (완전히 같은 것, 물리적으로 같은 것)
  + 동등성(Equality): ```equals()``` 메서드를 사용해서 두 객체가 논리적으로 동등한지 확인 (객체마다 동등성의 정의는 다름)
  + Object의 equals는 내부적으로 == 비교를 하기 때문에 필요한 경우에 오버라이딩해서 사용
- Class 클래스
  + 주요 기능
    - 타입 정보 얻기: 클래스의 이름, 슈퍼클래스, 인터페이스, 접근제어자 등과 같은 정보를 조회할 수 있다.
    - 리플랙션: 클래스에 정의된 메서드, 필드, 생성자 등을 조회하고 이들을 통해 객체 인스턴스를 생성하거나 메서드를 호출하는 등의 작업을 할 수 있다.
    - 동적 로딩 생성: ```Class.forName()``` 메서드를 사용하여 클래스를 동적으로 로드하고, ```newInstance()``` 메서드를 통해 새로운 인스턴스를 생성할 수 있다.
    - 애노테이션 처리: 클래스에 적용된 애노테이션(annotation)을 조회하고 처리하는 기능을 제공한다.

### 불변 객체
- 여러 변수가 하나의 객체를 공유하는 것을 막을 수 있는 방법이 없기 때문에
- 문제의 직접적인 원인인 값을 변경하는 것을 막는 객체
- 장점
  + 캐시 안정성
  + 멀티 쓰레드 안정성
  + 엔티티의 값 타입

### 객체지향
- 객체지향 vs 절차지향
  + 절차지향: 실행 순서를 중요하게 생각하는 방식으로 **어떻게**를 중심으로 한 프로그래밍
    - 한계: 데이터와 기능이 분리되어 있어 관리 포인트 증가
  + 객체지향: 객체를 중요하게 생각하는 방식으로 **무엇을**에 초점을 맞춘 프로그래밍
  + 둘의 큰 차이는 데이터(필드)와 해당 데이터에 대한 처리(메서드)가 객체 내부에 포함되어 있는지, 분리되어 있는지
- 캡슐화
  + 속성과 기능이 마치 하나의 캡슐에 쌓여 있는 것처럼 묶여져서 외부로 제공
  + 코드 가독성이 높아지고 변경에도 용이
  + 접근 제어자
    - private: 모든 외부 호출을 막음
    - default(package-private): 같은 패키지 안에서 호출은 허용 
    - protected: 같은 패키지 안에 있거나 다른 패키지라도 상속 관계 호출 허용
    - public: 모든 외부 호출 허용
  + 데이터(속성)은 숨겨라 -> 메서드를 통해 접근
  + 메서드를 숨겨라 -> 꼭 필요한 메서드만 제공
- SOLID
  + SRP(Single Responsibility Principle: 단일 책임 원칙)
    - 하나의 클래스는 하나의 책임을 가진다는 것으로 변경에 대한 파급이 적은 것이 핵심
  + OCP(Open Close Principle: 개방 폐쇄 원칙)
    - 다형성을 활용하여 확장에는 열려있고 변경에는 닫혀있게 만드는 것이 핵심
    - 다형성을 사용해도 객체를 생성하고 연관 관계를 맺어주는 별도의 생성자가 필요
  + LSP(Liskov Substitution Principle: 리스코프 치환 원칙)
    - 컴파일을 넘어 규약을 맞추고 하위 타입의 인스턴스로 변경이 가능해야 함
  + ISP(Interface Segregation Principle: 인터페이스 분리 원칙)
    - 특정 클라이언트를 위한 인터페이스 여러개가 범위 인터페이스보다 나음
  + DIP(Dependency Inversion Principle: 의존성 역전의 원칙)
    - 추상화에 의존하고 구체화에 의존하면 안된다는 것으로 역할에 의존하고 구현에 의존하지 말아야 한다는 것
   
### 버전 별 참고
- Java 8
- record
  + Java 14 버전에 나와 17에 정식으로 채택
  + request,response 등 한번 생성되면 변경이 없이 데이터만 전달하는 경우 기본적으로 작성해야 하는 코드들을 줄일 수 있도록 개발된 자료 구조
  + 모든 필드가 private final 로 되어 있고
- toList()
  + Java 8 때 collect(Collectors.toList()) 사용이 가능했지만 반환 리스트가 가변적이라 데이터를 더 추가할 수 있었고 NULL 값을 넣을 수 있도록 허용
  + Java 10 때 Collectors.toUnmodifiableList() 가 나왔고 반환 리스트가 불변이지만 NULL을 허용하지 않아 NULL 이 들어간 경우 NPE 발생
  + Java 16 때 Stream.toList() 가 나왔고 이는 반환 리스트가 불변이고 NULL을 허용

### 참고
- [김영한의 실전 자바 - 기본편](https://www.inflearn.com/course/%EA%B9%80%EC%98%81%ED%95%9C%EC%9D%98-%EC%8B%A4%EC%A0%84-%EC%9E%90%EB%B0%94-%EA%B8%B0%EB%B3%B8%ED%8E%B8/dashboard)

## Part 2. Spring Boot
### Spring Boot 의 특징
- Tomcat 같은 웹서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨
- 손쉬운 빌드 구성을 위한 stater 종속성 제공
- 스프링과 3th party 외부 라이브러리 자동 구성
- 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공
- 관례에 의한 간결한 설정

### 핵심 개념 & 컨셉
- 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크
- 역할과 구현을 나눠서 객체끼리 메시지를 주고 받으면서 협력하는 과정에서 클라이언트를 변경하지 않고 실행 시점에 객체를 유연하고 쉽게 변경할 수 있는 **다형성**을 활용
- 제어의 역전(IoC), 의존관계 주입(DI) 모두 다형성을 활용해서 역할과 구현을 편리하게 사용할 수 있게 지원
- 다형성만으로는 OCP, DIP를 위반하게 되므로 DI 컨테이너를 제공하여 객체 지향 원칙을 지킬 수 있게 함

### 빈(Bean)
- 라이프사이클(Life Cycle)
  + 스프링컨테이너생성 -> 스프링빈생성 -> 의존관계주입 -> 초기화콜백 -> 사용 -> 소멸전콜백 -> 스프링 종료
  + 스프링은 의존관계 주입이 완료되면 스프링 빈에게 콜백 메서드를 통해서 초기화 시점을 알려주는 다양한 기능을 제공한다. 또한 스프링은 스프링 컨테이너가 종료되기 직전에 소멸 콜백을 준다.
  + 초기화 콜백: 빈이 생성되고, 빈의 의존관계 주입이 완료된 후 호출 / 소멸전 콜백: 빈이 소멸되기 직전에 호출
  + 빈 생명주기 콜백
    - 인터페이스(InitializingBean, DisposableBean)
      + 스프링 전용 인터페이스로 스프링 의존적
      + 초기화, 소멸 메서드의 이름을 변경 불가
      + 내가 코드를 고칠 수 없는 외부 라이브러리에 적용 불가
    - 설정 정보에 초기화 메서드, 종료 메서드 지정
      + 메서드 이름을 자유롭게 지정
      + 스프링 빈이 스프링 코드에 의존하지 않음
      + 코드가 아니라 설정 정보를 사용하기 때문에 코드를 고칠 수 없는 외부 라이브러리에도 초기화, 종료 메서드를 적용 가능
      + destroyMethod의 경우 close 또는 shutdown이라는 이름의 메서드를 추론 가능
    - @PostConstruct, @PreDestroy 애노테이션 지원 (권장)
      + 애노테이션 하나만 붙이면 되므로 매우 편리
      + 스프링에 종속적인 기술이 아니라 javax.annotation.PostConstruct 패키지에 있는 JSR-250 라는 자바 표준으로 스프링이 아닌 다른 컨테이너에서도 동작
      + 컴포넌트 스캔과 잘 어울림
      + 유일한 단점은 외부 라이브러리에는 적용 불가하다는 것으로 외부 라이브러리를 초기화, 종료 해야 하면 @Bean의 초기화, 종료 메서드 기능을 사용
- 빈 스코프(Scope)
  + 싱글톤
    - 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프
  + 프로토타입
    - 스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계 주입, 초기화까지만 처리한 뒤, 클라이언트에 빈을 반환하고 이후 스프링 컨테이너는 생성된 프로토타입 빈을 관리하지 않음
    - 스프링 컨테이너에 요청할 때 마다 새로 생성
    - @PreDestroy 와 같은 종료 메서드가 호출되지 않기 때문에 그래서 프로토타입 빈은 프로토타입 빈을 조회한 클라이언트가 관리해야 하며 종료 메서드에 대한 호출도 클라이언트가 직접 해야함
    - 싱글톤 빈 내부에서 프로토타입 빈을 참조하는 경우 원하는대로 동작하지 않을 수 있기 때문에
      + 의존관계를 외부에서 주입(DI) 받는게 아니라 스프링의 애플리케이션 컨텍스트 전체를 주입받아 getBean 메서드를 통해 직접 필요한 의존관계를 찾는 Dependency Lookup (DL) 의존관계 조회(탐색)을 사용하거나
      + ObjectFactory나 편의 기능이 더 추가된 ObjectProvider를 사용할 수 있음
      + 또는 javax.inject.Provider 라는 JSR-330 자바 표준을 사용하는 방법이 있음
  + 웹 관련 스코프
    - 웹 스코프는 웹 환경에서만 동작하고 프로토타입과 다르게 스프링이 해당 스코프의 종료시점까지 관리하기 때문에 종료 메서드가 호출됨
    - 웹 스코프 종류
      + request: HTTP 요청 하나가 들어오고 나갈 때 까지 유지되는 스코프, 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성, 관리
      + session: HTTP Session과 동일한 생명주기를 가지는 스코프
      + application: 서블릿 컨텍스트(ServletContext)와 동일한 생명주기를 가지는 스코프
      + websocket: 웹 소켓과 동일한 생명주기를 가지는 스코프
    - proxyMode = ScopedProxyMode.TARGET_CLASS (인터페이스라면 INTERFACES)를 설정하면 스프링 컨테이너는 CGLIB 라는 바이트코드를 조작하는 라이브러리를 사용해서 가짜 프록시 클래스를 만들어두고 HTTP request와 상관 없이 가짜 프록시 클래스를 다른 빈에 미리 주입해 사용 가능
      + 실제 요청이 왔을 때 실제 객체를 호출하는 방식으로 동작 (가짜 프록시 객체는 싱글톤으로 동작)
      + 프록시 없이 주입 받으려면 request를 예로 들었을 때 요청이 들어오기 전에는 객체가 없기 때문에 Provider 등을 사용해야함

### DI(Dependency Injection)
- 왜 사용하는지?
- 방법
  + 생성자 주입 (권장)
    - 생성자를 통해서 의존 관계를 주입 받는 방법
    - 생성자 호출시점에 딱 1번만 호출되는 것이 보장된다. 불변, 필수 의존관계에 사용
    - 생성자가 딱 1개만 있으면 @Autowired를 생략해도 자동 주입 된다.
  + setter 주입
    - setter라 불리는 필드의 값을 변경하는 수정자 메서드를 통해서 의존관계를 주입하는 방법
    - 선택, 변경 가능성이 있는 의존관계에 사용
    - @Autowired 의 기본 동작은 주입할 대상이 없으면 오류가 발생한다. 주입할 대상이 없어도 동작하게 하려면 @Autowired(required = false) 로 지정
  + 필드 주입
    - 필드에 바로 주입하는 방법
    - 코드가 간결해서 많은 개발자들을 유혹하지만 외부에서 변경이 불가능해서 테스트 하기 힘들다는 치명적인 단점이 있다. DI 프레임워크가 없으면 아무것도 할 수 없다.
    - 애플리케이션의 실제 코드와 관계 없는 테스트 코드, 스프링 설정을 목적으로 하는 @Configuration 같은 곳에서만 특별한 용도로 사용

### AOP

