# Back to the BASIC
해당 디렉토리는 기본이 되는 언어, 프레임워크 등에 대해 다시 공부한 내용을 정리하는 임시 디렉토리입니다. 기본부터 탄탄하게! 🧱

- 기간(2개월): 2024-05 ~ 2024-07

## Part 1. Java
- [java-basic.md]()

## Part 2. Spring Boot
### Spring Boot 의 특징
- Tomcat 같은 웹서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨
- 손쉬운 빌드 구성을 위한 stater 종속성 제공
- 스프링과 3th party 외부 라이브러리 자동 구성
- 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공
- 관례에 의한 간결한 설정

### 핵심 개념 & 컨셉
- 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크
- 역할과 구현을 나눠서 객체끼리 메시지를 주고 받으면서 협력하는 과정에서 클라이언트를 변경하지 않고 실행 시점에 객체를 유연하고 쉽게 변경할 수 있는 **다형성**을 활용
- 제어의 역전(IoC), 의존관계 주입(DI) 모두 다형성을 활용해서 역할과 구현을 편리하게 사용할 수 있게 지원
- 다형성만으로는 OCP, DIP를 위반하게 되므로 DI 컨테이너를 제공하여 객체 지향 원칙을 지킬 수 있게 함

### 빈(Bean)
- 라이프사이클(Life Cycle)
  + 스프링컨테이너생성 -> 스프링빈생성 -> 의존관계주입 -> 초기화콜백 -> 사용 -> 소멸전콜백 -> 스프링 종료
  + 스프링은 의존관계 주입이 완료되면 스프링 빈에게 콜백 메서드를 통해서 초기화 시점을 알려주는 다양한 기능을 제공한다. 또한 스프링은 스프링 컨테이너가 종료되기 직전에 소멸 콜백을 준다.
  + 초기화 콜백: 빈이 생성되고, 빈의 의존관계 주입이 완료된 후 호출 / 소멸전 콜백: 빈이 소멸되기 직전에 호출
  + 빈 생명주기 콜백
    - 인터페이스(InitializingBean, DisposableBean)
      + 스프링 전용 인터페이스로 스프링 의존적
      + 초기화, 소멸 메서드의 이름을 변경 불가
      + 내가 코드를 고칠 수 없는 외부 라이브러리에 적용 불가
    - 설정 정보에 초기화 메서드, 종료 메서드 지정
      + 메서드 이름을 자유롭게 지정
      + 스프링 빈이 스프링 코드에 의존하지 않음
      + 코드가 아니라 설정 정보를 사용하기 때문에 코드를 고칠 수 없는 외부 라이브러리에도 초기화, 종료 메서드를 적용 가능
      + destroyMethod의 경우 close 또는 shutdown이라는 이름의 메서드를 추론 가능
    - @PostConstruct, @PreDestroy 애노테이션 지원 (권장)
      + 애노테이션 하나만 붙이면 되므로 매우 편리
      + 스프링에 종속적인 기술이 아니라 javax.annotation.PostConstruct 패키지에 있는 JSR-250 라는 자바 표준으로 스프링이 아닌 다른 컨테이너에서도 동작
      + 컴포넌트 스캔과 잘 어울림
      + 유일한 단점은 외부 라이브러리에는 적용 불가하다는 것으로 외부 라이브러리를 초기화, 종료 해야 하면 @Bean의 초기화, 종료 메서드 기능을 사용
- 빈 스코프(Scope)
  + 싱글톤
    - 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프
  + 프로토타입
    - 스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계 주입, 초기화까지만 처리한 뒤, 클라이언트에 빈을 반환하고 이후 스프링 컨테이너는 생성된 프로토타입 빈을 관리하지 않음
    - 스프링 컨테이너에 요청할 때 마다 새로 생성
    - @PreDestroy 와 같은 종료 메서드가 호출되지 않기 때문에 그래서 프로토타입 빈은 프로토타입 빈을 조회한 클라이언트가 관리해야 하며 종료 메서드에 대한 호출도 클라이언트가 직접 해야함
    - 싱글톤 빈 내부에서 프로토타입 빈을 참조하는 경우 원하는대로 동작하지 않을 수 있기 때문에
      + 의존관계를 외부에서 주입(DI) 받는게 아니라 스프링의 애플리케이션 컨텍스트 전체를 주입받아 getBean 메서드를 통해 직접 필요한 의존관계를 찾는 Dependency Lookup (DL) 의존관계 조회(탐색)을 사용하거나
      + ObjectFactory나 편의 기능이 더 추가된 ObjectProvider를 사용할 수 있음
      + 또는 javax.inject.Provider 라는 JSR-330 자바 표준을 사용하는 방법이 있음
  + 웹 관련 스코프
    - 웹 스코프는 웹 환경에서만 동작하고 프로토타입과 다르게 스프링이 해당 스코프의 종료시점까지 관리하기 때문에 종료 메서드가 호출됨
    - 웹 스코프 종류
      + request: HTTP 요청 하나가 들어오고 나갈 때 까지 유지되는 스코프, 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성, 관리
      + session: HTTP Session과 동일한 생명주기를 가지는 스코프
      + application: 서블릿 컨텍스트(ServletContext)와 동일한 생명주기를 가지는 스코프
      + websocket: 웹 소켓과 동일한 생명주기를 가지는 스코프
    - proxyMode = ScopedProxyMode.TARGET_CLASS (인터페이스라면 INTERFACES)를 설정하면 스프링 컨테이너는 CGLIB 라는 바이트코드를 조작하는 라이브러리를 사용해서 가짜 프록시 클래스를 만들어두고 HTTP request와 상관 없이 가짜 프록시 클래스를 다른 빈에 미리 주입해 사용 가능
      + 실제 요청이 왔을 때 실제 객체를 호출하는 방식으로 동작 (가짜 프록시 객체는 싱글톤으로 동작)
      + 프록시 없이 주입 받으려면 request를 예로 들었을 때 요청이 들어오기 전에는 객체가 없기 때문에 Provider 등을 사용해야함

### DI(Dependency Injection)
- 왜 사용하는지?
- 방법
  + 생성자 주입 (권장)
    - 생성자를 통해서 의존 관계를 주입 받는 방법
    - 생성자 호출시점에 딱 1번만 호출되는 것이 보장된다. 불변, 필수 의존관계에 사용
    - 생성자가 딱 1개만 있으면 @Autowired를 생략해도 자동 주입 된다.
  + setter 주입
    - setter라 불리는 필드의 값을 변경하는 수정자 메서드를 통해서 의존관계를 주입하는 방법
    - 선택, 변경 가능성이 있는 의존관계에 사용
    - @Autowired 의 기본 동작은 주입할 대상이 없으면 오류가 발생한다. 주입할 대상이 없어도 동작하게 하려면 @Autowired(required = false) 로 지정
  + 필드 주입
    - 필드에 바로 주입하는 방법
    - 코드가 간결해서 많은 개발자들을 유혹하지만 외부에서 변경이 불가능해서 테스트 하기 힘들다는 치명적인 단점이 있다. DI 프레임워크가 없으면 아무것도 할 수 없다.
    - 애플리케이션의 실제 코드와 관계 없는 테스트 코드, 스프링 설정을 목적으로 하는 @Configuration 같은 곳에서만 특별한 용도로 사용

### AOP

