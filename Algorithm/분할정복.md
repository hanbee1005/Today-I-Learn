# 분할 정복
```Divide and Conquer```       
기본적으로는 엄청나게 크고 방대한 문제를 조금씩 조금씩 나눠가면서 용이하게 풀 수 있는 문제 단위로 나눈 다음 그것들을 다시 합쳐서 해결하자는 개념에서 출발하였다. 대표적으로는 **퀵소트나 병합정렬**이 있다.

- 분할: 문제를 더이상 분할할 수 없을 때까지 동일한 유형의 여러 하위 문제로 나눈다.
- 정복: 가장 작은 단위의 하위 문제를 해결하여 정복한다.
- 조합: 하위 문제에 대한 결과를 원래 문제에 대한 결과로 조합한다.

### 적용 방식
- 병합 정렬
  + 원소 개수가 1 또는 0이 될 때까지 두 부분으로 쪼개고 쪼개서 자른 순서의 역순으로 크기를 비교해 병합해 나간다. 병합된 부분 안은 이미 정렬되어 있으므로 전부 비교하지 않아도 제자리를 찾을 수 있다.
  + 성능은 퀵 정렬보다 전반적으로 뒤떨어지고, 데이터 크기만한 메모리가 더 필요하지만 최대의 장점은 데이터의 상태에 별 영향을 받지 않는다는 점이다. 
  + 힙이나 퀵의 경우에는 배열 A[25]=100, A[33]=100인 정수형 배열을 정렬한다고 할 때, 33번째에 있던 100이 25번째에 있던 100보다 앞으로 오는 경우가 생길 수 있다. 그에 반해서 병합정렬은 이런 일이 발생하지 않는다. 기본적으로 병합정렬은 쪼갠 후 두 값을 비교할 때 값이 같으면 정렬하지 않게 설계되기 때문이다. 실제 상황에서 여러 기준으로 정렬했을 때 동일 값에 대해선 기존 기준의 정렬순서가 유지되어야 한다.
  <img src="./images/01.merge-sort-concept.png" alt="merge_sort" width="200"/>
- 퀵소트
  + 적절한 원소 하나를 기준(피벗, pivot)으로 삼아 그보다 작은 것을 앞으로 빼내고 그 뒤에 피벗을 옮겨 피벗보다 작은 것, 큰 것으로 나눈뒤 나누어진 각각에서 다시 피벗을 잡고 정렬해서 각각의 크기가 0이나 1이 될 때까지 정렬한다. 
  + 이렇게 피벗을 잡고 이보다 작은 원소들을 왼쪽으로, 보다 큰 원소들을 오른쪽으로 나누는걸 partition step이라 한다. 퀵 정렬에도 이 partition step을 어떻게 하느냐에 따라 바리에이션이 매우 많으며, 성능 차이도 날 수 있다.
- 이진 탐색

### 장점
- 정렬 알고리즘 비교
  + 선택 정렬과 삽입 정렬의 최대 실행시간은 O(n^2)이다. 입력하는 배열의 크기가 크다면 이 알고리즘으로 정렬하는데 매우 오랜 시간이 걸릴 수 있다.
  + 반면 분할정복 알고리즘을 사용하는 합병 정렬의 실행시간은 모든 경우에 대해 O(nlgn)으로 , 퀵 정렬은 최대 O(n^2)이지만 최선이나 평균의 경우 **O(nlgn)으로 비교적 빠른 시간**을 갖는 것을 볼 수 있다.
- Top-down 재귀방식으로 구현하기 때문에 코드가 직관적이다.
- 문제를 나누어 해결한다는 특징상 병렬적으로 문제를 해결할 수 있다.

### 단점
- 재귀 함수 호츨로 오버헤드가 발생할 수 있다.
- 스택에 다량의 데이터가 보관되는 경우 오버플로우가 발생할 수 있다.

### 샘플 문제 풀이
- [백준 2740 - 행렬 곱셈](https://github.com/hanbee1005/AlgorithmStudy/blob/master/BaekjoonAlgorithm/202205/Q2740.java)
- [백준 10830 - 행렬 제곱](https://github.com/hanbee1005/AlgorithmStudy/blob/master/BaekjoonAlgorithm/202210/Q10830.java)

### 참고
- https://namu.wiki/w/%EB%B6%84%ED%95%A0%20%EC%A0%95%EB%B3%B5%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98
- https://loosie.tistory.com/237
